<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Advanced R Solutions</title>
  <meta name="description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R.">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="Advanced R Solutions" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/advrs_cover.png" />
  <meta property="og:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="github-repo" content="Tazinho/Advanced-R-Solutions" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Advanced R Solutions" />
  
  <meta name="twitter:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="twitter:image" content="images/advrs_cover.png" />

<meta name="author" content="Malte Grosser, Henning Bumann, Peter Hurford &amp; Robert Krzyzanowski">


<meta name="date" content="2017-07-20">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="performance.html">
<link rel="next" href="memory.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- COLLAPSIBLE TEXT WITH OPEN ALL/CLOSE ALL LINK -->

<!-- This goes into the HEAD of the html file -->

<script language="JavaScript" type="text/javascript">
<!-- Copyright 2007, Sandeep Gangadharan -->
<!-- For more free scripts go to http://www.sivamdesign.com/scripts/ -->
<!--
if (document.getElementById) {
 document.write('<style type="text/css">.texter {display:none; border-left:white 20px solid; color:#404040; font-family:verdana,arial,helvetica,sans-serif; font-size:9pt} @media print {.texter {display:block;}}</style>') }

 var divNum = new Array("a1","a2","a3");  // at the left you should add a1, a2 etc. for each header you wish to include
                                          // so if you want 4 headers you should add a1, a2, a3, a4 in the format shown
                                          // enclosed in double quotes
function openClose(theID) {
 for(var i=0; i < divNum.length; i++) {
  if (divNum[i] == theID) {
   if (document.getElementById(divNum[i]).style.display == "block") { document.getElementById(divNum[i]).style.display = "none" }
   else { document.getElementById(divNum[i]).style.display = "block" }
  }
  else { document.getElementById(divNum[i]).style.display = "none"; }
 }
}

function openAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "block";
 }
}

function closeAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "none";
 }
}
// -->
</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="1" data-path="data-structures.html"><a href="data-structures.html"><i class="fa fa-check"></i><b>1</b> Data structures</a><ul>
<li class="chapter" data-level="1.1" data-path="data-structures.html"><a href="data-structures.html#vectors"><i class="fa fa-check"></i><b>1.1</b> Vectors</a></li>
<li class="chapter" data-level="1.2" data-path="data-structures.html"><a href="data-structures.html#attributes"><i class="fa fa-check"></i><b>1.2</b> Attributes</a></li>
<li class="chapter" data-level="1.3" data-path="data-structures.html"><a href="data-structures.html#matrices-and-arrays"><i class="fa fa-check"></i><b>1.3</b> Matrices and arrays</a></li>
<li class="chapter" data-level="1.4" data-path="data-structures.html"><a href="data-structures.html#data-frames"><i class="fa fa-check"></i><b>1.4</b> Data frames</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="subsetting.html"><a href="subsetting.html"><i class="fa fa-check"></i><b>2</b> Subsetting</a><ul>
<li class="chapter" data-level="2.1" data-path="subsetting.html"><a href="subsetting.html#data-types"><i class="fa fa-check"></i><b>2.1</b> Data types</a></li>
<li class="chapter" data-level="2.2" data-path="subsetting.html"><a href="subsetting.html#subsetting-operators"><i class="fa fa-check"></i><b>2.2</b> Subsetting operators</a></li>
<li class="chapter" data-level="2.3" data-path="subsetting.html"><a href="subsetting.html#applications"><i class="fa fa-check"></i><b>2.3</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>3</b> Functions</a><ul>
<li class="chapter" data-level="3.1" data-path="functions.html"><a href="functions.html#function-components"><i class="fa fa-check"></i><b>3.1</b> Function components</a></li>
<li class="chapter" data-level="3.2" data-path="functions.html"><a href="functions.html#lexical-scoping"><i class="fa fa-check"></i><b>3.2</b> Lexical Scoping</a></li>
<li class="chapter" data-level="3.3" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>3.3</b> Function arguments</a></li>
<li class="chapter" data-level="3.4" data-path="functions.html"><a href="functions.html#special-calls"><i class="fa fa-check"></i><b>3.4</b> Special calls</a></li>
<li class="chapter" data-level="3.5" data-path="functions.html"><a href="functions.html#return-values"><i class="fa fa-check"></i><b>3.5</b> Return Values</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="oo-field-guide.html"><a href="oo-field-guide.html"><i class="fa fa-check"></i><b>4</b> OO field guide</a><ul>
<li class="chapter" data-level="4.1" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s3"><i class="fa fa-check"></i><b>4.1</b> S3</a></li>
<li class="chapter" data-level="4.2" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s4"><i class="fa fa-check"></i><b>4.2</b> S4</a></li>
<li class="chapter" data-level="4.3" data-path="oo-field-guide.html"><a href="oo-field-guide.html#rc"><i class="fa fa-check"></i><b>4.3</b> RC</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="environments.html"><a href="environments.html"><i class="fa fa-check"></i><b>5</b> Environments</a><ul>
<li class="chapter" data-level="5.1" data-path="environments.html"><a href="environments.html#environment-basics"><i class="fa fa-check"></i><b>5.1</b> Environment basics</a></li>
<li class="chapter" data-level="5.2" data-path="environments.html"><a href="environments.html#recursing-over-environments"><i class="fa fa-check"></i><b>5.2</b> Recursing over environments</a></li>
<li class="chapter" data-level="5.3" data-path="environments.html"><a href="environments.html#function-environments"><i class="fa fa-check"></i><b>5.3</b> Function environments</a></li>
<li class="chapter" data-level="5.4" data-path="environments.html"><a href="environments.html#binding-names-to-values"><i class="fa fa-check"></i><b>5.4</b> Binding names to values</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html"><i class="fa fa-check"></i><b>6</b> Exceptions and debugging</a><ul>
<li class="chapter" data-level="6.1" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#condition-handling"><i class="fa fa-check"></i><b>6.1</b> Condition handling</a></li>
<li class="chapter" data-level="6.2" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#defensive-programming"><i class="fa fa-check"></i><b>6.2</b> Defensive programming</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="functional-programming.html"><a href="functional-programming.html"><i class="fa fa-check"></i><b>7</b> Functional programming</a><ul>
<li class="chapter" data-level="7.1" data-path="functional-programming.html"><a href="functional-programming.html#annonymous-functions"><i class="fa fa-check"></i><b>7.1</b> Annonymous functions</a></li>
<li class="chapter" data-level="7.2" data-path="functional-programming.html"><a href="functional-programming.html#closures"><i class="fa fa-check"></i><b>7.2</b> Closures</a></li>
<li class="chapter" data-level="7.3" data-path="functional-programming.html"><a href="functional-programming.html#lists-of-functions"><i class="fa fa-check"></i><b>7.3</b> Lists of functions</a></li>
<li class="chapter" data-level="7.4" data-path="functional-programming.html"><a href="functional-programming.html#case-study-numerical-integration"><i class="fa fa-check"></i><b>7.4</b> Case study: numerical integration</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="functionals.html"><a href="functionals.html"><i class="fa fa-check"></i><b>8</b> Functionals</a><ul>
<li class="chapter" data-level="8.1" data-path="functionals.html"><a href="functionals.html#my-first-functional-lapply"><i class="fa fa-check"></i><b>8.1</b> My first functional: lapply()</a></li>
<li class="chapter" data-level="8.2" data-path="functionals.html"><a href="functionals.html#for-loops-functionals-friends-of-lapply"><i class="fa fa-check"></i><b>8.2</b> For loops functionals: friends of lapply():</a></li>
<li class="chapter" data-level="8.3" data-path="functionals.html"><a href="functionals.html#manipulating-matrices-and-data-frames"><i class="fa fa-check"></i><b>8.3</b> Manipulating matrices and data frames</a></li>
<li class="chapter" data-level="8.4" data-path="functionals.html"><a href="functionals.html#manipulating-lists"><i class="fa fa-check"></i><b>8.4</b> Manipulating lists</a></li>
<li class="chapter" data-level="8.5" data-path="functionals.html"><a href="functionals.html#mathematical-functionals"><i class="fa fa-check"></i><b>8.5</b> Mathematical functionals</a></li>
<li class="chapter" data-level="8.6" data-path="functionals.html"><a href="functionals.html#a-family-of-functions"><i class="fa fa-check"></i><b>8.6</b> A family of functions</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="function-operators.html"><a href="function-operators.html"><i class="fa fa-check"></i><b>9</b> Function operators</a><ul>
<li class="chapter" data-level="9.1" data-path="function-operators.html"><a href="function-operators.html#behavioural-fos"><i class="fa fa-check"></i><b>9.1</b> Behavioural FOs</a></li>
<li class="chapter" data-level="9.2" data-path="function-operators.html"><a href="function-operators.html#output-fos"><i class="fa fa-check"></i><b>9.2</b> Output FOs</a></li>
<li class="chapter" data-level="9.3" data-path="function-operators.html"><a href="function-operators.html#input-fos"><i class="fa fa-check"></i><b>9.3</b> Input FOs</a></li>
<li class="chapter" data-level="9.4" data-path="function-operators.html"><a href="function-operators.html#combining-fos"><i class="fa fa-check"></i><b>9.4</b> Combining FOs</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html"><i class="fa fa-check"></i><b>10</b> Non standard evaluation</a><ul>
<li class="chapter" data-level="10.1" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#capturing-expressions"><i class="fa fa-check"></i><b>10.1</b> Capturing expressions</a></li>
<li class="chapter" data-level="10.2" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#non-standard-evaluation-in-subset"><i class="fa fa-check"></i><b>10.2</b> Non standard evaluation in subset</a></li>
<li class="chapter" data-level="10.3" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#scoping-issues"><i class="fa fa-check"></i><b>10.3</b> Scoping issues</a></li>
<li class="chapter" data-level="10.4" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#calling-from-another-function"><i class="fa fa-check"></i><b>10.4</b> Calling from another function</a></li>
<li class="chapter" data-level="10.5" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#substitute"><i class="fa fa-check"></i><b>10.5</b> Substitute</a></li>
<li class="chapter" data-level="10.6" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#the-downsides-of-non-standard-evaluation"><i class="fa fa-check"></i><b>10.6</b> The downsides of non-standard evaluation</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>11</b> Expressions</a><ul>
<li class="chapter" data-level="11.1" data-path="expressions.html"><a href="expressions.html#structure-of-expressions"><i class="fa fa-check"></i><b>11.1</b> Structure of expressions</a></li>
<li class="chapter" data-level="11.2" data-path="expressions.html"><a href="expressions.html#names"><i class="fa fa-check"></i><b>11.2</b> Names</a></li>
<li class="chapter" data-level="11.3" data-path="expressions.html"><a href="expressions.html#calls"><i class="fa fa-check"></i><b>11.3</b> Calls</a></li>
<li class="chapter" data-level="11.4" data-path="expressions.html"><a href="expressions.html#capturing-the-current-call"><i class="fa fa-check"></i><b>11.4</b> Capturing the current call</a></li>
<li class="chapter" data-level="11.5" data-path="expressions.html"><a href="expressions.html#pairlists"><i class="fa fa-check"></i><b>11.5</b> Pairlists</a></li>
<li class="chapter" data-level="11.6" data-path="expressions.html"><a href="expressions.html#parsing-and-deparsing"><i class="fa fa-check"></i><b>11.6</b> Parsing and deparsing</a></li>
<li class="chapter" data-level="11.7" data-path="expressions.html"><a href="expressions.html#walking-the-ast-with-recursive-functions"><i class="fa fa-check"></i><b>11.7</b> Walking the AST with recursive functions</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html"><i class="fa fa-check"></i><b>12</b> Domain specific languages</a><ul>
<li class="chapter" data-level="12.1" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#html"><i class="fa fa-check"></i><b>12.1</b> HTML</a></li>
<li class="chapter" data-level="12.2" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#latex"><i class="fa fa-check"></i><b>12.2</b> LaTeX</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="performance.html"><a href="performance.html"><i class="fa fa-check"></i><b>13</b> Performance</a><ul>
<li class="chapter" data-level="13.1" data-path="performance.html"><a href="performance.html#microbenchmarking"><i class="fa fa-check"></i><b>13.1</b> Microbenchmarking</a></li>
<li class="chapter" data-level="13.2" data-path="performance.html"><a href="performance.html#language-performance"><i class="fa fa-check"></i><b>13.2</b> Language performance</a></li>
<li class="chapter" data-level="13.3" data-path="performance.html"><a href="performance.html#implementations-performance"><i class="fa fa-check"></i><b>13.3</b> Implementations performance</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="profiling.html"><a href="profiling.html"><i class="fa fa-check"></i><b>14</b> Profiling</a><ul>
<li class="chapter" data-level="14.1" data-path="profiling.html"><a href="profiling.html#has-somebody-already-solved-the-problem"><i class="fa fa-check"></i><b>14.1</b> Has somebody already solved the problem?</a></li>
<li class="chapter" data-level="14.2" data-path="profiling.html"><a href="profiling.html#do-as-little-as-possible"><i class="fa fa-check"></i><b>14.2</b> Do as little as possible</a></li>
<li class="chapter" data-level="14.3" data-path="profiling.html"><a href="profiling.html#vectorise"><i class="fa fa-check"></i><b>14.3</b> Vectorise</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="memory.html"><a href="memory.html"><i class="fa fa-check"></i><b>15</b> Memory</a><ul>
<li class="chapter" data-level="15.1" data-path="memory.html"><a href="memory.html#object-size"><i class="fa fa-check"></i><b>15.1</b> Object size</a></li>
<li class="chapter" data-level="15.2" data-path="memory.html"><a href="memory.html#memory-profiling-with-lineprof"><i class="fa fa-check"></i><b>15.2</b> Memory profiling with lineprof</a></li>
<li class="chapter" data-level="15.3" data-path="memory.html"><a href="memory.html#modification-in-place"><i class="fa fa-check"></i><b>15.3</b> Modification in place</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>16</b> Rcpp</a><ul>
<li class="chapter" data-level="16.1" data-path="rcpp.html"><a href="rcpp.html#getting-started-with-c"><i class="fa fa-check"></i><b>16.1</b> Getting started with C++</a></li>
<li class="chapter" data-level="16.2" data-path="rcpp.html"><a href="rcpp.html#missing-values"><i class="fa fa-check"></i><b>16.2</b> Missing values</a></li>
<li class="chapter" data-level="16.3" data-path="rcpp.html"><a href="rcpp.html#the-stl"><i class="fa fa-check"></i><b>16.3</b> The STL</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="testchapter.html"><a href="testchapter.html"><i class="fa fa-check"></i><b>17</b> Testchapter</a></li>
<li class="chapter" data-level="18" data-path="s3-1.html"><a href="s3-1.html"><i class="fa fa-check"></i><b>18</b> S3</a><ul>
<li class="chapter" data-level="18.1" data-path="s3-1.html"><a href="s3-1.html#basics"><i class="fa fa-check"></i><b>18.1</b> Basics</a></li>
<li class="chapter" data-level="18.2" data-path="s3-1.html"><a href="s3-1.html#classes"><i class="fa fa-check"></i><b>18.2</b> Classes</a></li>
<li class="chapter" data-level="18.3" data-path="s3-1.html"><a href="s3-1.html#generics-and-methods"><i class="fa fa-check"></i><b>18.3</b> Generics and methods</a></li>
<li class="chapter" data-level="18.4" data-path="s3-1.html"><a href="s3-1.html#method-dispatch"><i class="fa fa-check"></i><b>18.4</b> Method dispatch</a></li>
<li class="chapter" data-level="18.5" data-path="s3-1.html"><a href="s3-1.html#inheritance"><i class="fa fa-check"></i><b>18.5</b> Inheritance</a></li>
<li class="chapter" data-level="18.6" data-path="s3-1.html"><a href="s3-1.html#dispatch-details"><i class="fa fa-check"></i><b>18.6</b> Dispatch details</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="s4-1.html"><a href="s4-1.html"><i class="fa fa-check"></i><b>19</b> S4</a><ul>
<li class="chapter" data-level="19.1" data-path="s4-1.html"><a href="s4-1.html#classes-1"><i class="fa fa-check"></i><b>19.1</b> Classes</a></li>
<li class="chapter" data-level="19.2" data-path="s4-1.html"><a href="s4-1.html#generics-and-methods-1"><i class="fa fa-check"></i><b>19.2</b> Generics and methods</a></li>
<li class="chapter" data-level="19.3" data-path="s4-1.html"><a href="s4-1.html#method-dispatch-1"><i class="fa fa-check"></i><b>19.3</b> Method dispatch</a></li>
<li class="chapter" data-level="19.4" data-path="s4-1.html"><a href="s4-1.html#s4-and-existing-code"><i class="fa fa-check"></i><b>19.4</b> S4 and existing code</a><ul>
<li class="chapter" data-level="19.4.1" data-path="s4-1.html"><a href="s4-1.html#exercises"><i class="fa fa-check"></i><b>19.4.1</b> Exercises</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Advanced R Solutions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="profiling" class="section level1">
<h1><span class="header-section-number">14</span> Profiling</h1>
<div id="has-somebody-already-solved-the-problem" class="section level2">
<h2><span class="header-section-number">14.1</span> Has somebody already solved the problem?</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: What are faster alternatives to <code>lm</code>? Which are specifically designed to work with larger datasets?</p>
<p><strong><span style="color:green">A</span></strong>: Within the <a href="https://cran.rstudio.com/web/views/">Cran task view</a> for <a href="https://cran.rstudio.com/web/views/HighPerformanceComputing.html">HighPerformanceComputing</a> we can find for example the <code>speedglm</code> package and it’s <code>speedlm()</code> function. We might not gain any performance improvements on small datasets:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(
  <span class="kw">coef</span>(speedglm::<span class="kw">speedlm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width +<span class="st"> </span>Species, <span class="dt">data =</span> iris)),
  <span class="kw">coef</span>(<span class="kw">lm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width +<span class="st"> </span>Species, <span class="dt">data =</span> iris))))

microbenchmark::<span class="kw">microbenchmark</span>(
  speedglm::<span class="kw">speedlm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width +<span class="st"> </span>Species, <span class="dt">data =</span> iris),
  <span class="kw">lm</span>(Sepal.Length ~<span class="st"> </span>Sepal.Width +<span class="st"> </span>Species, <span class="dt">data =</span> iris)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;                                                                  expr</span>
<span class="co">#&gt;  speedglm::speedlm(Sepal.Length ~ Sepal.Width + Species, data = iris)</span>
<span class="co">#&gt;                 lm(Sepal.Length ~ Sepal.Width + Species, data = iris)</span>
<span class="co">#&gt;       min       lq     mean   median       uq       max neval cld</span>
<span class="co">#&gt;  1124.244 1217.168 2297.108 1300.743 1379.371 98657.030   100   a</span>
<span class="co">#&gt;   932.533 1044.150 1166.039 1095.652 1189.858  3520.454   100   a</span></code></pre></div>
<p>However on bigger datasets it can make a difference:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">eps &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100000</span>)
x1 &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">100000</span>, <span class="dv">5</span>, <span class="dv">3</span>)
x2 &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;a&quot;</span>, <span class="st">&quot;b&quot;</span>), <span class="dv">50000</span>)
y &lt;-<span class="st"> </span><span class="dv">7</span> *<span class="st"> </span>x1 +<span class="st"> </span>(x2 ==<span class="st"> &quot;a&quot;</span>) +<span class="st"> </span>eps
td &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">y =</span> y, <span class="dt">x1 =</span> x1, <span class="dt">x2 =</span> x2, <span class="dt">eps =</span> eps)

<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(
  <span class="kw">coef</span>(speedglm::<span class="kw">speedlm</span>(y ~<span class="st"> </span>x1 +<span class="st"> </span>x2, <span class="dt">data =</span> td)),
  <span class="kw">coef</span>(<span class="kw">lm</span>(y ~<span class="st"> </span>x1 +<span class="st"> </span>x2, <span class="dt">data =</span> td))))

microbenchmark::<span class="kw">microbenchmark</span>(
  speedglm::<span class="kw">speedlm</span>(y ~<span class="st"> </span>x1 +<span class="st"> </span>x2, <span class="dt">data =</span> td),
  <span class="kw">lm</span>(y ~<span class="st"> </span>x1 +<span class="st"> </span>x2, <span class="dt">data =</span> td)
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;                                       expr      min       lq      mean</span>
<span class="co">#&gt;  speedglm::speedlm(y ~ x1 + x2, data = td) 52.68108 60.56802  77.98273</span>
<span class="co">#&gt;                 lm(y ~ x1 + x2, data = td) 84.96633 96.51705 119.38080</span>
<span class="co">#&gt;     median        uq      max neval cld</span>
<span class="co">#&gt;   64.56005  67.87945 187.9931   100  a </span>
<span class="co">#&gt;  100.50945 111.25207 223.0764   100   b</span></code></pre></div>
<p>For further speedinprovements, you might consider switching your linear algebra libraries as stated in <code>?speedglm::speedlm</code></p>
<blockquote>
<p>The functions of class ‘speedlm’ may speed up the fitting of LMs to large data sets. High performances can be obtained especially if R is linked against an optimized BLAS, such as ATLAS.</p>
</blockquote>
<p>Note that there are many other opportunities mentioned in the task view, also some that make it possible to handle data which is not in memory.</p>
<p>When it comes to pure speed a quick google search on <a href="http://stackoverflow.com/questions/25416413/is-there-a-faster-lm-function">r fastest lm</a> provides a stackoverflow thread where someone already solved this problem for us…</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What package implements a version of <code>match()</code> that’s faster for repeated lookups? How much faster is it?</p>
<p><strong><span style="color:green">A</span></strong>: Again google gives a good recommendation for the searchterm <a href="http://stackoverflow.com/questions/32934933/faster-in-operator">r faster match</a>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
table &lt;-<span class="st"> </span>1L:100000L
x &lt;-<span class="st"> </span><span class="kw">sample</span>(table, <span class="dv">10000</span>, <span class="dt">replace=</span><span class="ot">TRUE</span>)

<span class="kw">stopifnot</span>(<span class="kw">all.equal</span>(<span class="kw">match</span>(x, table), fastmatch::<span class="kw">fmatch</span>(x, table)))

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">match</span>(x, table),
  fastmatch::<span class="kw">fmatch</span>(x, table)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;                         expr       min         lq       mean     median</span>
<span class="co">#&gt;              match(x, table) 15880.167 16143.3580 16917.3927 16492.5080</span>
<span class="co">#&gt;  fastmatch::fmatch(x, table)   429.977   481.1125   687.6512   637.0835</span>
<span class="co">#&gt;         uq      max neval cld</span>
<span class="co">#&gt;  16993.048 22822.10   100   b</span>
<span class="co">#&gt;    825.313  1172.63   100  a</span></code></pre></div>
<p>On my laptop <code>fastmatch::fmatch()</code> is around 25 times as fast as <code>match()</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: List four functions (not just those in base R) that convert a string into a date time object. What are their strengths and weaknesses?</p>
<p><strong><span style="color:orange">A</span></strong>: At least these functions will do the trick: <code>as.POSIXct()</code>, <code>as.POSIXlt()</code>, <code>strftime()</code>, <code>strptime()</code>, <code>lubridate::ymd_hms()</code>. There might also be some in the timeseries packages <code>xts</code> or <code>zoo</code> and in <code>anytime</code>. An update on this will follow…</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: How many different ways can you compute a 1d density estimate in R?</p>
<p><strong><span style="color:green">A</span></strong>: According to <a href="https://www.google.de/url?sa=t&amp;rct=j&amp;q=&amp;esrc=s&amp;source=web&amp;cd=3&amp;ved=0ahUKEwim0sTI9JLRAhVScFAKHdLuBOIQFggxMAI&amp;url=http%3A%2F%2Fvita.had.co.nz%2Fpapers%2Fdensity-estimation.pdf&amp;usg=AFQjCNFBdOT4DvSTXtGoawIFkgf6JlXV9Q&amp;sig2=APnTeIL55Zj_0oATw15mBA&amp;cad=rja">Deng and Wickham (2011)</a> density estimation is implemented in over 20 R packages.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Which packages provide the ability to compute a rolling mean?</p>
<strong><span style="color:green">A</span></strong>: Again google <a href="http://stackoverflow.com/questions/743812/calculating-moving-average-in-r">r rolling mean</a> provides us with enough information and guides our attention on solutions in the following packages:
<ul>
<li><code>zoo</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">zoo::<span class="kw">rollmean</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">2</span>, <span class="dt">na.pad =</span> <span class="ot">TRUE</span>, <span class="dt">align =</span> <span class="st">&quot;left&quot;</span>)
<span class="co">#&gt;  [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5  NA</span>
zoo::<span class="kw">rollapply</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">2</span>, mean, <span class="dt">fill =</span> <span class="ot">NA</span>, <span class="dt">align =</span> <span class="st">&quot;left&quot;</span>)
<span class="co">#&gt;  [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5  NA</span></code></pre></div>
<ul>
<li><code>TTR</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">TTR::<span class="kw">SMA</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dv">2</span>)
<span class="co">#&gt;  [1]  NA 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5</span></code></pre></div>
<ul>
<li><code>RcppRoll</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">RcppRoll::<span class="kw">roll_mean</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">n =</span> <span class="dv">2</span>, <span class="dt">fill =</span> <span class="ot">NA</span>, <span class="dt">align =</span> <span class="st">&quot;left&quot;</span>)
<span class="co">#&gt;  [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5  NA</span></code></pre></div>
<ul>
<li><code>caTools</code></li>
</ul>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">caTools::<span class="kw">runmean</span>(<span class="dv">1</span>:<span class="dv">10</span>, <span class="dt">k =</span> <span class="dv">2</span>, <span class="dt">endrule =</span> <span class="st">&quot;NA&quot;</span>, <span class="dt">align =</span> <span class="st">&quot;left&quot;</span>)
<span class="co">#&gt;  [1] 1.5 2.5 3.5 4.5 5.5 6.5 7.5 8.5 9.5  NA</span></code></pre></div>
<p>Note that an exhaustive example on how to create a rolling mean function is provided in the <a href="http://adv-r.had.co.nz/Functionals.html">textbook</a>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What are the alternatives to <code>optim()</code>?</p>
<p><strong><span style="color:green">A</span></strong>: Depending on the usecase a lot of different options might be considered. For a general overview we would suggest the corresponding taskview on <a href="https://cran.r-project.org/web/views/Optimization.html">Optimization</a>.</p></li>
</ol>
</div>
<div id="do-as-little-as-possible" class="section level2">
<h2><span class="header-section-number">14.2</span> Do as little as possible</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: How do the results change if you compare <code>mean()</code> and <code>mean.default()</code> on 10,000 observations, rather than on 100?</p>
<p><strong><span style="color:green">A</span></strong>: We start with 100 observations as shown in the textbook:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e2</span>)
microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x)
)
<span class="co">#&gt; Unit: nanoseconds</span>
<span class="co">#&gt;             expr  min   lq    mean median   uq   max neval cld</span>
<span class="co">#&gt;          mean(x) 2566 2933 3684.53   3299 3300 44721   100   b</span>
<span class="co">#&gt;  mean.default(x)  733  734 1103.85   1100 1101  3666   100  a</span></code></pre></div>
<p>In case of 10000 observations we can observe that using <code>mean.default()</code> preserves only a small advantage over the use of <code>mean()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e4</span>)
microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x),
  <span class="dt">unit =</span> <span class="st">&quot;ns&quot;</span>
)
<span class="co">#&gt; Unit: nanoseconds</span>
<span class="co">#&gt;             expr   min    lq     mean median    uq    max neval cld</span>
<span class="co">#&gt;          mean(x) 19428 19795 20634.33  20161 20528  44721   100   a</span>
<span class="co">#&gt;  mean.default(x) 17228 17595 19157.02  17596 17962 122433   100   a</span></code></pre></div>
<p>When using even more observations - like in the next lines - it seems that <code>mean.default</code> doesn’t preserve anymore any advantage at all:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">x &lt;-<span class="st"> </span><span class="kw">runif</span>(<span class="fl">1e6</span>)
microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">mean</span>(x),
  <span class="kw">mean.default</span>(x),
  <span class="dt">unit =</span> <span class="st">&quot;ns&quot;</span>
)
<span class="co">#&gt; Unit: nanoseconds</span>
<span class="co">#&gt;             expr     min      lq    mean  median      uq     max neval cld</span>
<span class="co">#&gt;          mean(x) 1736402 1769759 1885408 1870563 1949923 2489318   100   a</span>
<span class="co">#&gt;  mean.default(x) 1713675 1786620 1880863 1870196 1956705 2330597   100   a</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: The following code provides an alternative implementation of <code>rowSums()</code>. Why is it faster for this input?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rowSums2 &lt;-<span class="st"> </span>function(df) {
  out &lt;-<span class="st"> </span>df[[1L]]
  if (<span class="kw">ncol</span>(df) ==<span class="st"> </span><span class="dv">1</span>) <span class="kw">return</span>(out)

  for (i in <span class="dv">2</span>:<span class="kw">ncol</span>(df)) {
    out &lt;-<span class="st"> </span>out +<span class="st"> </span>df[[i]]
  }
  out
}

df &lt;-<span class="st"> </span><span class="kw">as.data.frame</span>(
  <span class="kw">replicate</span>(<span class="fl">1e3</span>, <span class="kw">sample</span>(<span class="dv">100</span>, <span class="fl">1e4</span>, <span class="dt">replace =</span> <span class="ot">TRUE</span>))
)
<span class="kw">system.time</span>(<span class="kw">rowSums</span>(df))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;    0.05    0.00    0.05</span>
<span class="kw">system.time</span>(<span class="kw">rowSums2</span>(df))
<span class="co">#&gt;    user  system elapsed </span>
<span class="co">#&gt;    0.03    0.00    0.03</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What’s the difference between <code>rowSums()</code> and <code>.rowSums()</code>?</p>
<p><strong><span style="color:green">A</span></strong>: <code>.rowSums()</code> is defined as</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">.rowSums
<span class="co">#&gt; function (x, m, n, na.rm = FALSE) </span>
<span class="co">#&gt; .Internal(rowSums(x, m, n, na.rm))</span>
<span class="co">#&gt; &lt;bytecode: 0x000000001eda1f70&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre></div>
<p>this means, that the internal <code>rowSums()</code> function is called via <code>.Internal()</code>.</p>
<blockquote>
<p>.Internal performs a call to an internal code which is built in to the R interpreter.</p>
</blockquote>
<p>The internal <code>rowSums()</code> is a complete different function than the “normal” <code>rowSums()</code> function.</p>
<p>Of course (since they have the same name) in this case these functions are heavily related with each other: If we look into the source code of <code>rowSums()</code>, we see that it is a wrapper around the internal <code>rowSums()</code>. Just some input checkings, conversions and the special cases (complex numbers) are added:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">rowSums
<span class="co">#&gt; function (x, na.rm = FALSE, dims = 1L) </span>
<span class="co">#&gt; {</span>
<span class="co">#&gt;     if (is.data.frame(x)) </span>
<span class="co">#&gt;         x &lt;- as.matrix(x)</span>
<span class="co">#&gt;     if (!is.array(x) || length(dn &lt;- dim(x)) &lt; 2L) </span>
<span class="co">#&gt;         stop(&quot;&#39;x&#39; must be an array of at least two dimensions&quot;)</span>
<span class="co">#&gt;     if (dims &lt; 1L || dims &gt; length(dn) - 1L) </span>
<span class="co">#&gt;         stop(&quot;invalid &#39;dims&#39;&quot;)</span>
<span class="co">#&gt;     p &lt;- prod(dn[-(id &lt;- seq_len(dims))])</span>
<span class="co">#&gt;     dn &lt;- dn[id]</span>
<span class="co">#&gt;     z &lt;- if (is.complex(x)) </span>
<span class="co">#&gt;         .Internal(rowSums(Re(x), prod(dn), p, na.rm)) + (0+1i) * </span>
<span class="co">#&gt;             .Internal(rowSums(Im(x), prod(dn), p, na.rm))</span>
<span class="co">#&gt;     else .Internal(rowSums(x, prod(dn), p, na.rm))</span>
<span class="co">#&gt;     if (length(dn) &gt; 1L) {</span>
<span class="co">#&gt;         dim(z) &lt;- dn</span>
<span class="co">#&gt;         dimnames(z) &lt;- dimnames(x)[id]</span>
<span class="co">#&gt;     }</span>
<span class="co">#&gt;     else names(z) &lt;- dimnames(x)[[1L]]</span>
<span class="co">#&gt;     z</span>
<span class="co">#&gt; }</span>
<span class="co">#&gt; &lt;bytecode: 0x000000001a374778&gt;</span>
<span class="co">#&gt; &lt;environment: namespace:base&gt;</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Make a faster version of <code>chisq.test()</code> that only computes the chi-square test statistic when the input is two numeric vectors with no missing values. You can try simplifying <code>chisq.test()</code> or by coding from the <a href="http://en.wikipedia.org/wiki/Pearson%27s_chi-squared_test">mathematical definition</a>.</p>
<p><strong><span style="color:green">A</span></strong>: Since <code>chisq.test()</code> has a relatively long source code, we try a new implementation from scratch:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test2 &lt;-<span class="st"> </span>function(x, y){

  <span class="co"># Input</span>
  if(!<span class="kw">is.numeric</span>(x)){
    <span class="kw">stop</span>(<span class="st">&quot;x must be numeric&quot;</span>)}
  if(!<span class="kw">is.numeric</span>(y)){
    <span class="kw">stop</span>(<span class="st">&quot;y must be numeric&quot;</span>)}
  if(<span class="kw">length</span>(x) !=<span class="st"> </span><span class="kw">length</span>(y)){
    <span class="kw">stop</span>(<span class="st">&quot;x and y must have the same length&quot;</span>)}
  if(<span class="kw">length</span>(x) &lt;=<span class="st"> </span><span class="dv">1</span>){
    <span class="kw">stop</span>(<span class="st">&quot;length of x must be greater one&quot;</span>)}
  if(<span class="kw">any</span>(<span class="kw">c</span>(x,y) &lt;<span class="st"> </span><span class="dv">0</span>)){
    <span class="kw">stop</span>(<span class="st">&quot;all entries of x and y must be greater or equal zero&quot;</span>)}
  if(<span class="kw">sum</span>(<span class="kw">complete.cases</span>(x, y)) !=<span class="st"> </span><span class="kw">length</span>(x)){
    <span class="kw">stop</span>(<span class="st">&quot;there must be no missing values in x and y&quot;</span>)}
  if(<span class="kw">any</span>(<span class="kw">is.null</span>(<span class="kw">c</span>(x,y)))){
    <span class="kw">stop</span>(<span class="st">&quot;entries of x and y must not be NULL&quot;</span>)}

  <span class="co"># Help variables</span>
  m &lt;-<span class="st"> </span><span class="kw">rbind</span>(x, y)
  margin1 &lt;-<span class="st"> </span><span class="kw">rowSums</span>(m)
  margin2 &lt;-<span class="st"> </span><span class="kw">colSums</span>(m)
  n &lt;-<span class="st"> </span><span class="kw">sum</span>(m)
  me &lt;-<span class="st"> </span><span class="kw">tcrossprod</span>(margin1, margin2) /<span class="st"> </span>n

  <span class="co"># Output</span>
  x_stat =<span class="st"> </span><span class="kw">sum</span>((m -<span class="st"> </span>me)^<span class="dv">2</span> /<span class="st"> </span>me)
  dof &lt;-<span class="st"> </span>(<span class="kw">length</span>(margin1) -<span class="st"> </span><span class="dv">1</span>) *<span class="st"> </span>(<span class="kw">length</span>(margin2) -<span class="st"> </span><span class="dv">1</span>)
  p &lt;-<span class="st"> </span><span class="kw">pchisq</span>(x_stat, <span class="dt">df =</span> dof, <span class="dt">lower.tail =</span> <span class="ot">FALSE</span>)

  <span class="kw">return</span>(<span class="kw">list</span>(<span class="dt">x_stat =</span> x_stat, <span class="dt">df =</span> dof, <span class="st">`</span><span class="dt">p-value</span><span class="st">`</span> =<span class="st"> </span>p))
}</code></pre></div>
<p>We check if our new implementation returns the same results</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="dv">21</span>:<span class="dv">25</span>
b &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">21</span>,<span class="dv">23</span>,<span class="dv">25</span>,<span class="dv">27</span>,<span class="dv">29</span>)
m_test &lt;-<span class="st"> </span><span class="kw">cbind</span>(a, b)

<span class="kw">chisq.test</span>(m_test)
<span class="co">#&gt; </span>
<span class="co">#&gt;  Pearson&#39;s Chi-squared test</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; data:  m_test</span>
<span class="co">#&gt; X-squared = 0.16194, df = 4, p-value = 0.9969</span>
<span class="kw">chisq.test2</span>(a, b)
<span class="co">#&gt; $x_stat</span>
<span class="co">#&gt; [1] 0.1619369</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $df</span>
<span class="co">#&gt; [1] 4</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; $`p-value`</span>
<span class="co">#&gt; [1] 0.9968937</span></code></pre></div>
<p>Finally we benchmark this implementation against a compiled version of itself and the original <code>stats::chisq.test()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">chisq.test2c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(chisq.test2)

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">chisq.test</span>(m_test),
  <span class="kw">chisq.test2</span>(a, b),
  <span class="kw">chisq.test2c</span>(a, b)
)
<span class="co">#&gt; Unit: microseconds</span>
<span class="co">#&gt;                expr    min     lq     mean median      uq     max neval</span>
<span class="co">#&gt;  chisq.test(m_test) 65.982 68.914 77.14699 71.480 76.9785 229.834   100</span>
<span class="co">#&gt;   chisq.test2(a, b) 17.229 18.695 21.58368 20.161 23.8270  41.422   100</span>
<span class="co">#&gt;  chisq.test2c(a, b) 16.129 18.329 22.24348 19.978 23.6435  50.586   100</span>
<span class="co">#&gt;  cld</span>
<span class="co">#&gt;    b</span>
<span class="co">#&gt;   a </span>
<span class="co">#&gt;   a</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Can you make a faster version of <code>table()</code> for the case of an input of two integer vectors with no missing values? Can you use it to speed up your chi-square test?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Imagine you want to compute the bootstrap distribution of a sample correlation using <code>cor_df()</code> and the data in the example below. Given that you want to run this many times, how can you make this code faster? (Hint: the function has three components that you can speed up.)</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e6</span>
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">rnorm</span>(n), <span class="dt">b =</span> <span class="kw">rnorm</span>(n))

cor_df &lt;-<span class="st"> </span>function(df, n) {
  i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(n), n, <span class="dt">replace =</span> <span class="ot">FALSE</span> )
  <span class="kw">cor</span>(df[i, , <span class="dt">drop =</span> <span class="ot">FALSE</span>])[<span class="dv">2</span>,<span class="dv">1</span>]
  <span class="co"># note also that in the last line the textbook says q[] instead of df[]. Since</span>
  <span class="co"># this is probably just a typo, we changed this to df[].</span>
}</code></pre></div>
<p>Is there a way to vectorise this procedure?</p>
<p><strong><span style="color:green">A</span></strong>: The three components (mentioned in the questions hint) are:</p>
<ol style="list-style-type: decimal">
<li>sampling of indices</li>
<li>subsetting the data frame/conversion to matrix (or vector input)</li>
<li>the <code>cor()</code> function itself.</li>
</ol>
<p>Since a run of lineprof like shown in the textbook suggests that <code>as.matrix()</code> within the <code>cor()</code> function is the biggest bottleneck, we start with that:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">n &lt;-<span class="st"> </span><span class="fl">1e6</span>
df &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">a =</span> <span class="kw">rnorm</span>(n), <span class="dt">b =</span> <span class="kw">rnorm</span>(n))</code></pre></div>
<p>Remember the outgoing function:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_df &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(n), n, <span class="dt">replace =</span> <span class="ot">FALSE</span>)
  <span class="kw">cor</span>(df[i, , <span class="dt">drop =</span> <span class="ot">FALSE</span>])[<span class="dv">2</span>,<span class="dv">1</span>]
}</code></pre></div>
<p>First we want to optimise the second line (without attention to the <code>cor()</code> function itself). Therefore we exclude the first line from our optimisation approaches and define <code>i</code> within the global environment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(n), n)</code></pre></div>
<p>Then we define our approaches, check that their behaviour is correct and do the first benchmark:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># old version</span>
cor_v1 &lt;-<span class="st"> </span>function() {
  <span class="kw">cor</span>(df[i, , <span class="dt">drop =</span> <span class="ot">FALSE</span>])[<span class="dv">2</span>,<span class="dv">1</span>]
}

<span class="co"># cbind instead of internal as.matrix</span>
cor_v2 &lt;-<span class="st"> </span>function() {
  m &lt;-<span class="st"> </span><span class="kw">cbind</span>(df$a[i], df$b[i])
  <span class="kw">cor</span>(m)[<span class="dv">2</span>, <span class="dv">1</span>]
}

<span class="co"># cbind + vector subsetting of the output matrix</span>
cor_v3 &lt;-<span class="st"> </span>function() {
  m &lt;-<span class="st"> </span><span class="kw">cbind</span>(df$a[i], df$b[i])
  <span class="kw">cor</span>(m)[<span class="dv">2</span>]
}

<span class="co"># Use vector input within the cor function, so that no conversion is needed</span>
cor_v4 &lt;-<span class="st"> </span>function() {
  <span class="kw">cor</span>(df$a[i], df$b[i])
}

<span class="co"># check if all return the same result</span>
cor_list &lt;-<span class="st"> </span><span class="kw">list</span>(cor_v1, cor_v2, cor_v3, cor_v4)
ulapply &lt;-<span class="st"> </span>function(X, FUN, ...) <span class="kw">unlist</span>(<span class="kw">lapply</span>(X, FUN, ...))
<span class="kw">ulapply</span>(cor_list, function(x) <span class="kw">identical</span>(<span class="kw">x</span>(), <span class="kw">cor_v1</span>()))
<span class="co">#&gt; [1] TRUE TRUE TRUE TRUE</span>

<span class="co"># benchmark</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">cor_v1</span>(),
  <span class="kw">cor_v2</span>(),
  <span class="kw">cor_v3</span>(),
  <span class="kw">cor_v4</span>()
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;      expr       min        lq      mean    median        uq      max neval</span>
<span class="co">#&gt;  cor_v1() 577.70494 639.77457 693.54709 657.90616 714.82927 897.5469   100</span>
<span class="co">#&gt;  cor_v2()  56.33607  66.16119 119.65917  91.91469 103.74398 328.4110   100</span>
<span class="co">#&gt;  cor_v3()  56.69566  86.69540 122.43481  92.29628 127.05618 310.4690   100</span>
<span class="co">#&gt;  cor_v4()  51.65435  53.57824  86.62202  57.03712  89.26371 273.1739   100</span>
<span class="co">#&gt;  cld</span>
<span class="co">#&gt;    c</span>
<span class="co">#&gt;   b </span>
<span class="co">#&gt;   b </span>
<span class="co">#&gt;  a</span></code></pre></div>
<p>According to the resulting medians, lower and upper quartiles of our benchmark all three new versions seem to provide more or less the same speed benefit (note that the maximum and mean can vary a lot for these approaches). Since the second version is most similar to the code we started, we implement this line into a second version of <code>cor_df()</code> (if this sounds too arbitrary, note that in the final solution we will come back to the vector input version anyway) and do a benchmark to get the overall speedup:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_df2 &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample</span>(<span class="kw">seq</span>(n), n)
  m &lt;-<span class="st"> </span><span class="kw">cbind</span>(df$a[i], df$b[i])
  <span class="kw">cor</span>(m)[<span class="dv">2</span>, <span class="dv">1</span>]
}

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">cor_df</span>(),
  <span class="kw">cor_df2</span>()
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;       expr       min       lq     mean   median       uq       max neval</span>
<span class="co">#&gt;   cor_df() 637.16631 799.0702 870.8128 853.1700 921.7613 1259.3293   100</span>
<span class="co">#&gt;  cor_df2()  85.92746 118.3267 198.0209 159.6917 271.9692  424.2026   100</span>
<span class="co">#&gt;  cld</span>
<span class="co">#&gt;    b</span>
<span class="co">#&gt;   a</span></code></pre></div>
<p>Now we can focus on a speedup for the random generation of indices. (Note that a run of linepfrof suggests to optimize <code>cbind()</code>. However, after rewriting <code>cor()</code> to a version that only works with vector input, this step will be unnecessary anyway). We could try differnt approaches for the sequence generation within <code>sample()</code> (like <code>seq(n)</code>, <code>seq.int(n)</code>, <code>seq_len(n)</code>, <code>a:n</code>) and a direct call of <code>sample.int()</code>. In the following, we will see, that <code>sample.int()</code> is always faster (since we don’t include the generation of the sequence into our benchmark). When we look into <code>sample.int()</code> we see that it calls two different internal sample versions depending on the input. Since in our usecase always the second version will be called, we also provide this version in our benchmark:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">seq_n &lt;-<span class="st"> </span><span class="kw">seq</span>(n)

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">sample</span>(seq_n, n),
  <span class="kw">sample.int</span>(n, n),
  <span class="kw">.Internal</span>(<span class="kw">sample</span>(n, n, <span class="dt">replace =</span> <span class="ot">FALSE</span>, <span class="dt">prob =</span> <span class="ot">NULL</span>))
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;                                                   expr      min       lq</span>
<span class="co">#&gt;                                       sample(seq_n, n) 27.72120 29.33608</span>
<span class="co">#&gt;                                       sample.int(n, n) 16.38456 17.76539</span>
<span class="co">#&gt;  .Internal(sample(n, n, replace = FALSE, prob = NULL)) 17.00478 17.82661</span>
<span class="co">#&gt;      mean   median       uq      max neval cld</span>
<span class="co">#&gt;  33.84649 30.76310 37.06283 64.79227   100   b</span>
<span class="co">#&gt;  20.49919 18.41036 22.72442 39.22095   100  a </span>
<span class="co">#&gt;  20.18159 18.53957 21.33441 37.93359   100  a</span></code></pre></div>
<p>The <code>sample.int()</code> versions give clearly the biggest improvement. Since the internal version doesn’t provide any clear improvement, but restricts the general scope of our function, we choose to implement <code>sample.int()</code> in a third version of <code>cor_df()</code> and benchmark our actual achievements:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_df3 &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n, n)
  m &lt;-<span class="st"> </span><span class="kw">cbind</span>(df$a[i], df$b[i])
  <span class="kw">cor</span>(m)[<span class="dv">2</span>, <span class="dv">1</span>]
}

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">cor_df</span>(),
  <span class="kw">cor_df2</span>(),
  <span class="kw">cor_df3</span>()
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;       expr       min       lq     mean   median       uq       max neval</span>
<span class="co">#&gt;   cor_df() 648.18844 751.7812 849.9867 800.1750 920.4157 1293.7189   100</span>
<span class="co">#&gt;  cor_df2()  85.96851 105.5772 173.8860 133.1477 220.8880  627.3645   100</span>
<span class="co">#&gt;  cor_df3()  75.20261  80.8077 172.3101 112.0728 209.8121  879.0678   100</span>
<span class="co">#&gt;  cld</span>
<span class="co">#&gt;    b</span>
<span class="co">#&gt;   a </span>
<span class="co">#&gt;   a</span></code></pre></div>
<p>As a last step, we try to speedup the calculation of the pearson correlation coefficient. Since quite a lot of functionality is build into the <code>stats::cor()</code> function this seems like a reasonable approach. We try this by working with another <code>cor()</code> function from the <code>WGNA</code> package and an own implementation which should give a small improvement, because we use <code>sum(x) / length(x)</code> instead of <code>mean(x)</code> for internal calculations:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co">#WGCNA version (matrix and vector). Note that I don&#39;t use a local setup which uses</span>
<span class="co">#the full potential of this function. For furter information see ?WGCNA::cor</span>
cor_df4m &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n, n)
  m &lt;-<span class="st"> </span><span class="kw">cbind</span>(df$a[i], df$b[i])
  WGCNA::<span class="kw">cor</span>(m)[<span class="dv">2</span>]
}

cor_df4v &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n, n)
  WGCNA::<span class="kw">cor</span>(df$a[i], df$b[i], <span class="dt">quick =</span> <span class="dv">1</span>)[<span class="dv">1</span>]
}

<span class="co">#New implementation of underlying cor function</span>
<span class="co">#A definition can be found for example here</span>
<span class="co">#http://www.socscistatistics.com/tests/pearson/</span>
cor2 &lt;-<span class="st"> </span>function(x, y){
  xm &lt;-<span class="st"> </span><span class="kw">sum</span>(x) /<span class="st"> </span><span class="kw">length</span>(x)
  ym &lt;-<span class="st"> </span><span class="kw">sum</span>(y) /<span class="st"> </span><span class="kw">length</span>(y)
  x_xm &lt;-<span class="st"> </span>x -<span class="st"> </span>xm
  y_ym &lt;-<span class="st"> </span>y -<span class="st"> </span>ym
  numerator &lt;-<span class="st"> </span><span class="kw">sum</span>((x_xm) *<span class="st"> </span>(y_ym))
  denominator &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(x_xm^<span class="dv">2</span>)) *<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">sum</span>(y_ym^<span class="dv">2</span>))
  <span class="kw">return</span>(numerator /<span class="st"> </span>denominator)
}

cor2 &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor2)

cor_df5 &lt;-<span class="st"> </span>function() {
  i &lt;-<span class="st"> </span><span class="kw">sample.int</span>(n, n)
  <span class="kw">cor2</span>(df$a[i], df$b[i])
}</code></pre></div>
<p>In our final benchmark, we also include compiled verions of all our attempts:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor_df_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df)
cor_df2_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df2)
cor_df3_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df3)
cor_df4m_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df4m)
cor_df4v_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df4v)
cor_df5_c &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df5)

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">cor_df</span>(),
  <span class="kw">cor_df2</span>(),
  <span class="kw">cor_df3</span>(),
  <span class="kw">cor_df4m</span>(),
  <span class="kw">cor_df4v</span>(),
  <span class="kw">cor_df5</span>(),
  <span class="kw">cor_df_c</span>(),
  <span class="kw">cor_df2_c</span>(),
  <span class="kw">cor_df3_c</span>(),
  <span class="kw">cor_df4m_c</span>(),
  <span class="kw">cor_df4v_c</span>(),
  <span class="kw">cor_df5_c</span>()
)
<span class="co">#&gt; </span>
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;          expr      min       lq      mean    median        uq        max</span>
<span class="co">#&gt;      cor_df() 7.885838 9.146994 12.739322  9.844561 10.447188   83.08044</span>
<span class="co">#&gt;     cor_df2() 1.951941 3.178821  6.101036  3.339742  3.485085   36.25404</span>
<span class="co">#&gt;     cor_df3() 1.288831 1.943510  4.353773  2.018105  2.145119   66.74022</span>
<span class="co">#&gt;    cor_df4m() 1.534061 2.156848  6.344015  2.243540  2.370921  234.17307</span>
<span class="co">#&gt;    cor_df4v() 1.639997 2.271949  5.755720  2.349477  2.453214  196.49897</span>
<span class="co">#&gt;     cor_df5() 1.281133 1.879911  6.263500  1.932696  2.064292  237.83135</span>
<span class="co">#&gt;    cor_df_c() 7.600654 9.337239 13.613901 10.009330 10.965688   41.17146</span>
<span class="co">#&gt;   cor_df2_c() 2.009124 2.878242  5.645224  3.298138  3.469871   34.29037</span>
<span class="co">#&gt;   cor_df3_c() 1.312291 1.926281  4.426418  1.986948  2.094532   87.97220</span>
<span class="co">#&gt;  cor_df4m_c() 1.548357 2.179025  3.306796  2.242991  2.355709   23.87195</span>
<span class="co">#&gt;  cor_df4v_c() 1.669689 2.255087 27.148456  2.341962  2.490419 2263.33230</span>
<span class="co">#&gt;   cor_df5_c() 1.284065 1.888892  3.884798  1.953774  2.078955   25.81583</span>
<span class="co">#&gt;  neval cld</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span>
<span class="co">#&gt;    100   a</span></code></pre></div>
<p>Our final solution benefits most from the switch from data frames to vectors. Working with <code>sample.int</code> gives only little improvement. Reimplementing and compiling a new correlation function adds only minimal speedup.</p>
<p>To trust our final result we include a last check for similar return values:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">cor_df</span>()
<span class="co">#&gt; [1] -0.001441277</span>
<span class="kw">set.seed</span>(<span class="dv">1</span>)
<span class="kw">cor_df5_c</span>()
<span class="co">#&gt; [1] -0.001441277</span></code></pre></div>
<p>Vectorisation of this problem seems rather difficult, since attempts of using matrix calculus, always depend on building and handling big matrices in the first place.</p>
<p>We can for example rewrite our correlation function to work with matrices and build a new (vectorised) version of <code>cor_df()</code> on top of that</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cor2m &lt;-<span class="st"> </span>function(x, y){
  n_row &lt;-<span class="st"> </span><span class="kw">nrow</span>(x)
  xm &lt;-<span class="st"> </span><span class="kw">colSums</span>(x) /<span class="st"> </span>n_row
  ym &lt;-<span class="st"> </span><span class="kw">colSums</span>(y) /<span class="st"> </span>n_row
  x_xm &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">t</span>(x) -<span class="st"> </span>xm)
  y_ym &lt;-<span class="st"> </span><span class="kw">t</span>(<span class="kw">t</span>(y) -<span class="st"> </span>ym)
  numerator &lt;-<span class="st"> </span><span class="kw">colSums</span>((x_xm) *<span class="st"> </span>(y_ym))
  denominator &lt;-<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">colSums</span>(x_xm^<span class="dv">2</span>)) *<span class="st"> </span><span class="kw">sqrt</span>(<span class="kw">colSums</span>(y_ym^<span class="dv">2</span>))
  <span class="kw">return</span>(numerator /<span class="st"> </span>denominator)
}

cor_df_v &lt;-<span class="st"> </span>function(i){
  indices &lt;-<span class="st"> </span><span class="kw">replicate</span>(i, <span class="kw">sample.int</span>(n, n), <span class="dt">simplify =</span> <span class="st">&quot;array&quot;</span>)
  x &lt;-<span class="st"> </span><span class="kw">matrix</span>(df$a[indices], <span class="dt">ncol =</span> i)
  y &lt;-<span class="st"> </span><span class="kw">matrix</span>(df$b[indices], <span class="dt">ncol =</span> i)
  <span class="kw">cor2m</span>(x, y)
}
cor_df_v &lt;-<span class="st"> </span>compiler::<span class="kw">cmpfun</span>(cor_df_v)</code></pre></div>
<p>However this still doesn’t provide any improvement over the use of <code>lapply()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">ulapply2 &lt;-<span class="st"> </span>function(X, FUN, ...) <span class="kw">unlist</span>(<span class="kw">lapply</span>(X, FUN, ...), <span class="dt">use.names =</span> <span class="ot">FALSE</span>)

microbenchmark::<span class="kw">microbenchmark</span>(
  <span class="kw">cor_df5_c</span>(),
  <span class="kw">ulapply2</span>(<span class="dv">1</span>:<span class="dv">100</span>, function(x) <span class="kw">cor_df5_c</span>()),
  <span class="kw">cor_df_v</span>(<span class="dv">100</span>)
)
<span class="co">#&gt; Unit: milliseconds</span>
<span class="co">#&gt;                                      expr        min         lq      mean</span>
<span class="co">#&gt;                               cor_df5_c()   1.098219   1.148988   2.06762</span>
<span class="co">#&gt;  ulapply2(1:100, function(x) cor_df5_c()) 228.250897 233.052303 256.56849</span>
<span class="co">#&gt;                             cor_df_v(100) 263.158918 272.988449 312.43802</span>
<span class="co">#&gt;      median         uq      max neval cld</span>
<span class="co">#&gt;    1.864515   2.030201  13.2325   100 a  </span>
<span class="co">#&gt;  238.665277 247.184900 410.0768   100  b </span>
<span class="co">#&gt;  278.648158 291.164035 581.2834   100   c</span></code></pre></div>
<p>Further improvements can be achieved using parallelisation (for example via <code>parallel::parLapply()</code>)</p></li>
</ol>
</div>
<div id="vectorise" class="section level2">
<h2><span class="header-section-number">14.3</span> Vectorise</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: The density functions, e.g., <code>dnorm()</code>, have a common interface. Which arguments are vectorised over? What does <code>rnorm(10, mean = 10:1)</code> do?</p>
<p><strong><span style="color:green">A</span></strong>: We can see the interface of these functions via <code>?dnorm</code>:</p>
<pre><code>dnorm(x, mean = 0, sd = 1, log = FALSE)
pnorm(q, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
qnorm(p, mean = 0, sd = 1, lower.tail = TRUE, log.p = FALSE)
rnorm(n, mean = 0, sd = 1).</code></pre>
<p>They are vectorised over their numeric arguments, which is always the first argument (<code>x</code>, <code>a</code>, <code>p</code>, <code>n</code>), <code>mean</code> and <code>sd</code>. Note that it’s dangerous to supply a vector to <code>n</code> in the <code>rnorm()</code> function, since the behaviour will change, when <code>n</code> has length 1 (like in the second part of this question).</p>
<p><code>rnorm(10, mean = 10:1)</code> generates ten random numbers from different normal distributions. The normal distributions differ in their means. The first has mean ten, the second has mean nine, the third mean 8 etc.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Compare the speed of <code>apply(x, 1, sum)</code> with <code>rowSums(x)</code> for varying sizes of <code>x</code>.</p>
<p><strong><span style="color:green">A</span></strong>: We compare regarding different sizes for square matrices:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(microbenchmark)
dimensions &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">1e0</span>, <span class="fl">1e1</span>, <span class="fl">1e2</span>, <span class="fl">1e3</span>, <span class="fl">0.5e4</span>, <span class="fl">1e4</span>)
matrices &lt;-<span class="st">  </span><span class="kw">lapply</span>(dimensions,
                function(x) <span class="kw">tcrossprod</span>(<span class="kw">rnorm</span>(x), <span class="kw">rnorm</span>(x)))

bench_rs &lt;-<span class="st"> </span><span class="kw">lapply</span>(matrices,
                   function(x) <span class="kw">fivenum</span>(<span class="kw">microbenchmark</span>(<span class="kw">rowSums</span>(x),
                                                      <span class="dt">unit =</span> <span class="st">&quot;ns&quot;</span>)$time))
bench_rs &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">time =</span> <span class="kw">unlist</span>(bench_rs), 
                       <span class="dt">call =</span> <span class="st">&quot;rowSums&quot;</span>,
                       <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

bench_apply &lt;-<span class="st"> </span><span class="kw">lapply</span>(matrices,
                      function(x) <span class="kw">fivenum</span>(<span class="kw">microbenchmark</span>(<span class="kw">apply</span>(x, <span class="dv">1</span>, sum),
                                                         <span class="dt">unit =</span> <span class="st">&quot;ns&quot;</span>)$time))
bench_apply &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">time =</span> <span class="kw">unlist</span>(bench_apply),
                          <span class="dt">call =</span> <span class="st">&quot;apply&quot;</span>, <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

df &lt;-<span class="st"> </span><span class="kw">rbind</span>(bench_rs, bench_apply)

df$dimension &lt;-<span class="st"> </span><span class="kw">rep</span>(dimensions, <span class="dt">each =</span> <span class="dv">5</span>)
df$aggr &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;min&quot;</span>, <span class="st">&quot;lq&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;uq&quot;</span>, <span class="st">&quot;max&quot;</span>),
               <span class="dt">times =</span> <span class="kw">length</span>(dimensions))
df$aggr_size &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>), <span class="dt">times =</span> <span class="kw">length</span>(dimensions))
df$group &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">as.character</span>(df$call), <span class="kw">as.character</span>(df$aggr), <span class="dt">sep =</span> <span class="st">&quot; &quot;</span>)

<span class="kw">library</span>(ggplot2)

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(<span class="dt">x =</span> dimension, <span class="dt">y =</span> time, <span class="dt">colour =</span> call, <span class="dt">group =</span> group)) +
<span class="st">  </span><span class="kw">geom_point</span>() +<span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">linetype =</span> <span class="kw">factor</span>(aggr_size, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;3&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;1&quot;</span>))),
        <span class="dt">show.legend =</span> <span class="ot">FALSE</span>) </code></pre></div>
<p><img src="14-Profiling_files/figure-html/long%20calculation-1.png" width="672" /></p>
<p>The graph is a good indicator to notice, that <code>apply()</code> is not “vectorised for performance”.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: How can you use <code>crossprod()</code> to compute a weighted sum? How much faster is it than the naive <code>sum(x * w)</code>?</p>
<p><strong><span style="color:green">A</span></strong>: We can just give the vectors to <code>crossprod()</code> which converts them to row- and columnvectors and then multiplies these. The result is the dot product which is also a weighted sum.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">a &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
b &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">10</span>)
<span class="kw">sum</span>(a *<span class="st"> </span>b) -<span class="st"> </span><span class="kw">crossprod</span>(a, b)[<span class="dv">1</span>]
<span class="co">#&gt; [1] 0</span></code></pre></div>
<p>A benchmark of both alternatives for different vector lengths indicates, that the <code>crossprod()</code> variant is about 2.5 times faster than <code>sum()</code>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">dimensions &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="fl">1e1</span>, <span class="fl">1e2</span>, <span class="fl">1e3</span>, <span class="fl">1e4</span>, <span class="fl">1e5</span>, <span class="fl">1e6</span>, <span class="fl">0.5e7</span>, <span class="fl">1e7</span>)
xvector &lt;-<span class="st"> </span><span class="kw">lapply</span>(dimensions, rnorm)
weights &lt;-<span class="st"> </span><span class="kw">lapply</span>(dimensions, rnorm)

bench_sum &lt;-<span class="st"> </span><span class="kw">Map</span>(function(x, y) <span class="kw">fivenum</span>(<span class="kw">microbenchmark</span>(<span class="kw">sum</span>(x *<span class="st"> </span>y))$time),
                 xvector, weights)
bench_sum &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">time =</span> <span class="kw">unlist</span>(bench_sum),
                        <span class="dt">call =</span> <span class="st">&quot;sum&quot;</span>,
                        <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)
bench_cp &lt;-<span class="st"> </span><span class="kw">Map</span>(function(x, y) <span class="kw">fivenum</span>(<span class="kw">microbenchmark</span>(<span class="kw">crossprod</span>(x, y)[<span class="dv">1</span>])$time),
                xvector, weights)
bench_cp &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">time =</span> <span class="kw">unlist</span>(bench_cp),
                       <span class="dt">call =</span> <span class="st">&quot;crossproduct&quot;</span>,
                       <span class="dt">stringsAsFactors =</span> <span class="ot">FALSE</span>)

df &lt;-<span class="st"> </span><span class="kw">rbind</span>(bench_sum, bench_cp)

df$dimension &lt;-<span class="st"> </span><span class="kw">rep</span>(dimensions, <span class="dt">each =</span> <span class="dv">5</span>)
df$aggr &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="st">&quot;min&quot;</span>, <span class="st">&quot;lq&quot;</span>, <span class="st">&quot;median&quot;</span>, <span class="st">&quot;uq&quot;</span>, <span class="st">&quot;max&quot;</span>), <span class="dt">times =</span> <span class="kw">length</span>(dimensions))
df$aggr_size &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="kw">c</span>(<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>), <span class="dt">times =</span> <span class="kw">length</span>(dimensions))
df$group &lt;-<span class="st"> </span><span class="kw">paste</span>(<span class="kw">as.character</span>(df$call), <span class="kw">as.character</span>(df$aggr), <span class="dt">sep =</span> <span class="st">&quot; &quot;</span>)

<span class="kw">ggplot</span>(df, <span class="kw">aes</span>(<span class="dt">x =</span> dimension, <span class="dt">y =</span> time, <span class="dt">colour =</span> call, <span class="dt">group =</span> group)) +
<span class="st">  </span><span class="kw">geom_point</span>() +<span class="st"> </span>
<span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">linetype =</span> <span class="kw">factor</span>(aggr_size, <span class="dt">levels =</span> <span class="kw">c</span>(<span class="st">&quot;3&quot;</span>, <span class="st">&quot;2&quot;</span>, <span class="st">&quot;1&quot;</span>))),
            <span class="dt">show.legend =</span> <span class="ot">FALSE</span>) +
<span class="st">  </span><span class="kw">scale_y_continuous</span>(<span class="dt">expand =</span> <span class="kw">c</span>(<span class="dv">0</span>,<span class="dv">0</span>))</code></pre></div>
<p><img src="14-Profiling_files/figure-html/unnamed-chunk-32-1.png" width="672" /></p></li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="performance.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="memory.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Tazinho/Advanced-R-Solutions/edit/master/14-Profiling.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
