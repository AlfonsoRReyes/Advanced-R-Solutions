# Testchapter

# S3

## Basics

1.  __<span style="color:red">Q</span>__: The most important S3 objects in base R are factors, data frames, and date/times (Dates, POSIXct, POSIXlt). You've already seen the attributes and base type that factors are built on. What base types and attributes are the others built on?
    
    __<span style="color:green">A</span>__: 
    
    **data frame:** Data frames are build up on (named) lists. Together with the `row.names` attribute and after setting the class to "data.frame", we get a classical data frame
    
    ```{r}
    df_build <- structure(list(1:2, 3:4),
                          names = c("a", "b"),
                          row.names = 1:2, 
                          class = "data.frame")
    
    df_classic <- data.frame(a = 1:2, b = 3:4)
    
    identical(df_build, df_classic)
    ```
    
    **date/times (Dates, POSIXct, POSIXlt):** Date is just a double with the class attribute set to "Date"
    
    ```{r}
    date_build <- structure(0, class = "Date")
    date_classic <- as.Date("1970-01-01")
    identical(date_build, date_classic)
    ```
    
    POSIXct is a class for date/times that inherits from POSIXt and is built on doubles as well. The only attribute is tz (for timezone)
    
    ```{r}
    POSIXct_build <- structure(1, class = c("POSIXct", "POSIXt"), tzone = "CET")
    POSIXct_classic <- .POSIXct(1, tz = "CET") # note that tz's default is NULL
    identical(POSIXct_build, POSIXct_classic)
    ```
    
    POSIXlt is another date/time class that inherits from POSIXt. It is built on top of a named list and a tzone attribute. Differences between POSIXct and POSIXlt are described in `?DateTimeClasses`.
    
    ```{r}
    POSIXlt_build <- structure(list(sec = 30,
                                    min = 30L,
                                    hour = 14L,
                                    mday = 1L,
                                    mon = 0L,
                                    year = 70L,
                                    wday = 4L,
                                    yday = 0L,
                                    isdst = 0L,
                                    zone = "CET",
                                    gmtoff = 3600L),
                               tzone = c("", "CET", "CEST"),
                               class = c("POSIXlt", "POSIXt"))
    POSIXlt_classic <- as.POSIXlt(.POSIXct(13.5 * 3600 + 30))
    identical(POSIXlt_build, POSIXlt_classic)
    ```

1.  __<span style="color:red">Q</span>__: Describe the difference in behaviour in these two calls.

    ```{r}
    set.seed(1014)
    some_days <- as.Date("2017-01-31") + sample(10, 5)
    
    mean(some_days)
    mean(unclass(some_days))
    ```
    
    __<span style="color:green">A</span>__: Since `mean()` is a generic and `some_days` is an object of class "Date", the first call results in `mean.Date(some_days)`.  
    
    In the second call `unclass()` removes the class attribute from `some_days`, which means that `unclass(some_days)` is not an OO object and the call results in `mean.default(unclass(some_days))`, which calculates the mean of the underlying double.  
    
    When you look into the source code of `mean.Date()` (one line) you will see, that the difference in the resulting objects is again only the class attribute.

1.  __<span style="color:red">Q</span>__: Draw a Venn diagram illustrating the relationships between functions, generics, and methods.
    
    __<span style="color:orange">A</span>__ Need to check, if a method can also be a generic (should be possible). Otherwise just two distinct circles inside a third.

1.  __<span style="color:red">Q</span>__: What does the `as.data.frame.data.frame()` method do? Why is
    it confusing? How should you avoid this confusion in your own
    code?
    
    __<span style="color:green">A</span>__: `as.data.frame.data.frame()` is the method for data frames of the `as.data.frame()` generic. Methods of this generic generally coerce objects to data frames.  
    This specific method strips all class attributes preceding the "data.frame" class.  
    If row names are supplied, this method will check their length and then set these as new "row.names" attribute.
    
    The name is confusing, because it is not clear, from the name, if it is a normal function, a generic or a method. Even if we know, that it is a method, the name doesn't tell us, which part is the name of the generic and which part is the class name.  
We can easily avoid this confusion, by forgoing to use period separated class and function names.

1.  __<span style="color:red">Q</span>__: What does the following code return? What base type is built on?
    What attributes does it use?
    
    ```{r}
    x <- ecdf(rpois(100, 10))
    x
    ```
    
    __<span style="color:green">A</span>__: It returns the Empirical Cumulative Distribution Function of `rpois(100, 10)`. It is built on the base type "closure" and it saves the expression, which was used to create it, in its `call` attribute.

## Classes

1.  __<span style="color:red">Q</span>__: Categorise the objects returned by `lm()`, `factor()`, `table()`, 
    `as.Date()`, `ecdf()`, `ordered()`, `I()` into "vector", "scalar", and 
    "other".
    
    __<span style="color:green">A</span>__: 
    
    vector: `factor()`, `table()`, `as.Date()`, `ordered()`  
    scalar: `lm()`  
    other: `ecdf()`, `I()`  

1.  __<span style="color:red">Q</span>__: Write a constructor for `difftime` objects. What base type are they built on? What attributes do they use? You'll need to consult the documentation, read some code, and perform some experiments.
    
    __<span style="color:green">A</span>__: Our constructor should be named `new_class_name`, have one argument for it's base type and each attribute and check the base types of these arguments as well. 
    
    ```{r}
    new_difftime <- function(x, units = "auto") {
      stopifnot(is.double(x), is.character(units))
      
      structure(x, units = units, class = "difftime")
    }
    ```
    
    However, since the following test prints awkward, we get a little bit more inspiration by the original `difftime()` function:
    
    ```{r}
    new_difftime(3)
    ```
    
    Basically we need to implement the logic for the units, when they are set to `"auto"` and convert the value of the underlying double from seconds to the regarding unit, as also commented.
    
    ```{r}
    new_difftime <- function(x, units = "auto") {
      stopifnot(is.double(x), is.character(units))
      
      # case units == "auto":
      if (units == "auto") 
        # when all timedifferences are NA, units should be "secs"
        units <- if (all(is.na(x))){
          "secs"
        } else {
          # otherwise set the units regarding to the minimal time difference
          x_min <- min(abs(x), na.rm = TRUE)
          if (!is.finite(x_min) || x_min < 60) {
            "secs"
          } else if (x_min < 3600){
            "mins"
          } else if (x_min < 86400){
            "hours"
          } else {
            "days"
          }
        }
      
      # we rescale the underlying double, according to the units
      x <- switch(units, 
                  secs = x,
                  mins = x/60,
                  hours = x/3600,
                  days = x/86400,
                  weeks = x/(7 * 86400))
      
      structure(x, units = units, class = "difftime")
    }
    
    # test
    new_difftime(c(NA, -3600, 86400))
    ```

1.  Write a constructor for `data.frame` objects. What base type is a data 
    frame built on? What attributes does it use? What are the restrictions 
    placed on the individual elements? What about the names?

1.  Enhance our `factor()` helper to have better behaviour when one or
    more `values` is not found in `levels`. What does `base::factor()` do
    in this situation?

1.  Carefully read the source code of `factor()`. What does it do that
    our constructor does not?

1.  What would a constructor function for `lm` objects, `new_lm()`, look like?
    Why is a constructor function less useful for linear models?

## Generics and methods

1.  Read the source code for `t()` and `t.test()` and confirm that 
    `t.test()` is an S3 generic and not an S3 method. What happens if 
    you create an object with class `test` and call `t()` with it? Why?
    
    ```{r}
    x <- structure(1:10, class = "test")
    t(x)
    ```

1.  Carefully read the documentation for `UseMethod()` and explain why the
    following code returns the results that it does. What two usual rules
    of function evaluation does `UseMethod()` violate?
    
    ```{r}
    g <- function(x) {
      x <- 10
      y <- 10
      UseMethod("g")
    }
    g.default <- function(x) c(x = x, y = y)
    
    x <- 1
    y <- 1
    g(x)
    ```

## Method dispatch

1.  Which base generic has the greatest number of defined methods?

1.  Explain what is happening in the following code.

    ```{r}
    generic2 <- function(x) UseMethod("generic2")
    generic2.a1 <- function(x) "a1"
    generic2.a2 <- function(x) "a2"
    generic2.b <- function(x) {
      class(x) <- "a1"
      NextMethod()
    }

    generic2(S3::new_s3_scalar(class = c("b", "a2")))
    ```

## Inheritance

1.  The `ordered` class is a subclass of `factor`, but it's implemented in a very ad hoc way in base R. Implement it in a principled way by building a constructor and an `as_ordered` generic.
    
    ```{r}
    f1 <- factor("a", c("a", "b"))
    as.factor(f1)  
    as.ordered(f1) # loses levels
    ```
    
1.  What classes have a method for the `Math` group generic in base R? Read the source code. How do the methods work?

1.  R has two classes for representing date time data, `POSIXct` and 
    `POSIXlt`, which both inherit from `POSIXt`. Which generics have 
    different behaviours for the two classes? Which generics share the same behaviour?

## Dispatch details

1.  `Math.difftime()` is more complicated than I described. Why?


# S4

## Classes

1.  What happens if you define a new S4 class that doesn't "contain" an 
    existing class?  (Hint: read about virtual classes in `?setClass`.)

1.  Imagine you were going to rewrite ordered factors, dates, and 
    data frames in S4. Sketch out the `setClass()` calls that you would
    use to define the classes.

## Generics and methods

1.  In the defintion of the generic, why is it necessary to repeat the
    name of the generic twice?
    
1.  What happens if you define a method with different argument names to
    the generic?

1.  What other ways can you find help for a method? Read `?"?"` and
    summarise the details.

## Method dispatch 

1.  Take the last example which shows multiple dispatch over two classes that
    use multiple inheritance. What happens if you define a method for all
    terminal classes? Why does method dispatch not save us much work here?

## S4 and existing code

### Exercises

[S4-bioconductor]: http://www.bioconductor.org/help/course-materials/2010/AdvancedR/S4InBioconductor.pdf
[S4DA]: http://amzn.com/0387759352?tag=devtools-20
[SO-Morgan]: http://stackoverflow.com/search?tab=votes&q=user%3a547331%20%5bs4%5d%20is%3aanswe

