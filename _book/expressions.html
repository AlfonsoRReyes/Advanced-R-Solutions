<!DOCTYPE html>
<html >

<head>

  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title>Advanced R Solutions</title>
  <meta name="description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R.">
  <meta name="generator" content="bookdown 0.4 and GitBook 2.6.7">

  <meta property="og:title" content="Advanced R Solutions" />
  <meta property="og:type" content="book" />
  
  <meta property="og:image" content="images/advrs_cover.png" />
  <meta property="og:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="github-repo" content="Tazinho/Advanced-R-Solutions" />

  <meta name="twitter:card" content="summary" />
  <meta name="twitter:title" content="Advanced R Solutions" />
  
  <meta name="twitter:description" content="Solutions to the exercises in Hadley Wickham’s book Advanced R." />
  <meta name="twitter:image" content="images/advrs_cover.png" />

<meta name="author" content="Malte Grosser, Henning Bumann, Peter Hurford &amp; Robert Krzyzanowski">


<meta name="date" content="2017-07-16">

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  
  
<link rel="prev" href="non-standard-evaluation.html">
<link rel="next" href="domain-specific-languages.html">
<script src="libs/jquery-2.2.3/jquery.min.js"></script>
<link href="libs/gitbook-2.6.7/css/style.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-bookdown.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-highlight.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-search.css" rel="stylesheet" />
<link href="libs/gitbook-2.6.7/css/plugin-fontsettings.css" rel="stylesheet" />







<!-- COLLAPSIBLE TEXT WITH OPEN ALL/CLOSE ALL LINK -->

<!-- This goes into the HEAD of the html file -->

<script language="JavaScript" type="text/javascript">
<!-- Copyright 2007, Sandeep Gangadharan -->
<!-- For more free scripts go to http://www.sivamdesign.com/scripts/ -->
<!--
if (document.getElementById) {
 document.write('<style type="text/css">.texter {display:none; border-left:white 20px solid; color:#404040; font-family:verdana,arial,helvetica,sans-serif; font-size:9pt} @media print {.texter {display:block;}}</style>') }

 var divNum = new Array("a1","a2","a3");  // at the left you should add a1, a2 etc. for each header you wish to include
                                          // so if you want 4 headers you should add a1, a2, a3, a4 in the format shown
                                          // enclosed in double quotes
function openClose(theID) {
 for(var i=0; i < divNum.length; i++) {
  if (divNum[i] == theID) {
   if (document.getElementById(divNum[i]).style.display == "block") { document.getElementById(divNum[i]).style.display = "none" }
   else { document.getElementById(divNum[i]).style.display = "block" }
  }
  else { document.getElementById(divNum[i]).style.display = "none"; }
 }
}

function openAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "block";
 }
}

function closeAll() {
 for(var i=0; i < divNum.length; i++) {
   document.getElementById(divNum[i]).style.display = "none";
 }
}
// -->
</script>


<style type="text/css">
div.sourceCode { overflow-x: auto; }
table.sourceCode, tr.sourceCode, td.lineNumbers, td.sourceCode {
  margin: 0; padding: 0; vertical-align: baseline; border: none; }
table.sourceCode { width: 100%; line-height: 100%; }
td.lineNumbers { text-align: right; padding-right: 4px; padding-left: 4px; color: #aaaaaa; border-right: 1px solid #aaaaaa; }
td.sourceCode { padding-left: 5px; }
code > span.kw { color: #007020; font-weight: bold; } /* Keyword */
code > span.dt { color: #902000; } /* DataType */
code > span.dv { color: #40a070; } /* DecVal */
code > span.bn { color: #40a070; } /* BaseN */
code > span.fl { color: #40a070; } /* Float */
code > span.ch { color: #4070a0; } /* Char */
code > span.st { color: #4070a0; } /* String */
code > span.co { color: #60a0b0; font-style: italic; } /* Comment */
code > span.ot { color: #007020; } /* Other */
code > span.al { color: #ff0000; font-weight: bold; } /* Alert */
code > span.fu { color: #06287e; } /* Function */
code > span.er { color: #ff0000; font-weight: bold; } /* Error */
code > span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
code > span.cn { color: #880000; } /* Constant */
code > span.sc { color: #4070a0; } /* SpecialChar */
code > span.vs { color: #4070a0; } /* VerbatimString */
code > span.ss { color: #bb6688; } /* SpecialString */
code > span.im { } /* Import */
code > span.va { color: #19177c; } /* Variable */
code > span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code > span.op { color: #666666; } /* Operator */
code > span.bu { } /* BuiltIn */
code > span.ex { } /* Extension */
code > span.pp { color: #bc7a00; } /* Preprocessor */
code > span.at { color: #7d9029; } /* Attribute */
code > span.do { color: #ba2121; font-style: italic; } /* Documentation */
code > span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code > span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code > span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
</style>

</head>

<body>



  <div class="book without-animation with-summary font-size-2 font-family-1" data-basepath=".">

    <div class="book-summary">
      <nav role="navigation">

<ul class="summary">
<li class="chapter" data-level="" data-path="index.html"><a href="index.html"><i class="fa fa-check"></i>Prerequisites</a></li>
<li class="chapter" data-level="1" data-path="data-structures.html"><a href="data-structures.html"><i class="fa fa-check"></i><b>1</b> Data structures</a><ul>
<li class="chapter" data-level="1.1" data-path="data-structures.html"><a href="data-structures.html#vectors"><i class="fa fa-check"></i><b>1.1</b> Vectors</a></li>
<li class="chapter" data-level="1.2" data-path="data-structures.html"><a href="data-structures.html#attributes"><i class="fa fa-check"></i><b>1.2</b> Attributes</a></li>
<li class="chapter" data-level="1.3" data-path="data-structures.html"><a href="data-structures.html#matrices-and-arrays"><i class="fa fa-check"></i><b>1.3</b> Matrices and arrays</a></li>
<li class="chapter" data-level="1.4" data-path="data-structures.html"><a href="data-structures.html#data-frames"><i class="fa fa-check"></i><b>1.4</b> Data frames</a></li>
</ul></li>
<li class="chapter" data-level="2" data-path="subsetting.html"><a href="subsetting.html"><i class="fa fa-check"></i><b>2</b> Subsetting</a><ul>
<li class="chapter" data-level="2.1" data-path="subsetting.html"><a href="subsetting.html#data-types"><i class="fa fa-check"></i><b>2.1</b> Data types</a></li>
<li class="chapter" data-level="2.2" data-path="subsetting.html"><a href="subsetting.html#subsetting-operators"><i class="fa fa-check"></i><b>2.2</b> Subsetting operators</a></li>
<li class="chapter" data-level="2.3" data-path="subsetting.html"><a href="subsetting.html#applications"><i class="fa fa-check"></i><b>2.3</b> Applications</a></li>
</ul></li>
<li class="chapter" data-level="3" data-path="functions.html"><a href="functions.html"><i class="fa fa-check"></i><b>3</b> Functions</a><ul>
<li class="chapter" data-level="3.1" data-path="functions.html"><a href="functions.html#function-components"><i class="fa fa-check"></i><b>3.1</b> Function components</a></li>
<li class="chapter" data-level="3.2" data-path="functions.html"><a href="functions.html#lexical-scoping"><i class="fa fa-check"></i><b>3.2</b> Lexical Scoping</a></li>
<li class="chapter" data-level="3.3" data-path="functions.html"><a href="functions.html#function-arguments"><i class="fa fa-check"></i><b>3.3</b> Function arguments</a></li>
<li class="chapter" data-level="3.4" data-path="functions.html"><a href="functions.html#special-calls"><i class="fa fa-check"></i><b>3.4</b> Special calls</a></li>
<li class="chapter" data-level="3.5" data-path="functions.html"><a href="functions.html#return-values"><i class="fa fa-check"></i><b>3.5</b> Return Values</a></li>
</ul></li>
<li class="chapter" data-level="4" data-path="oo-field-guide.html"><a href="oo-field-guide.html"><i class="fa fa-check"></i><b>4</b> OO field guide</a><ul>
<li class="chapter" data-level="4.1" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s3"><i class="fa fa-check"></i><b>4.1</b> S3</a></li>
<li class="chapter" data-level="4.2" data-path="oo-field-guide.html"><a href="oo-field-guide.html#s4"><i class="fa fa-check"></i><b>4.2</b> S4</a></li>
<li class="chapter" data-level="4.3" data-path="oo-field-guide.html"><a href="oo-field-guide.html#rc"><i class="fa fa-check"></i><b>4.3</b> RC</a></li>
</ul></li>
<li class="chapter" data-level="5" data-path="environments.html"><a href="environments.html"><i class="fa fa-check"></i><b>5</b> Environments</a><ul>
<li class="chapter" data-level="5.1" data-path="environments.html"><a href="environments.html#environment-basics"><i class="fa fa-check"></i><b>5.1</b> Environment basics</a></li>
<li class="chapter" data-level="5.2" data-path="environments.html"><a href="environments.html#recursing-over-environments"><i class="fa fa-check"></i><b>5.2</b> Recursing over environments</a></li>
<li class="chapter" data-level="5.3" data-path="environments.html"><a href="environments.html#function-environments"><i class="fa fa-check"></i><b>5.3</b> Function environments</a></li>
<li class="chapter" data-level="5.4" data-path="environments.html"><a href="environments.html#binding-names-to-values"><i class="fa fa-check"></i><b>5.4</b> Binding names to values</a></li>
</ul></li>
<li class="chapter" data-level="6" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html"><i class="fa fa-check"></i><b>6</b> Exceptions and debugging</a><ul>
<li class="chapter" data-level="6.1" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#condition-handling"><i class="fa fa-check"></i><b>6.1</b> Condition handling</a></li>
<li class="chapter" data-level="6.2" data-path="exceptions-and-debugging.html"><a href="exceptions-and-debugging.html#defensive-programming"><i class="fa fa-check"></i><b>6.2</b> Defensive programming</a></li>
</ul></li>
<li class="chapter" data-level="7" data-path="functional-programming.html"><a href="functional-programming.html"><i class="fa fa-check"></i><b>7</b> Functional programming</a><ul>
<li class="chapter" data-level="7.1" data-path="functional-programming.html"><a href="functional-programming.html#annonymous-functions"><i class="fa fa-check"></i><b>7.1</b> Annonymous functions</a></li>
<li class="chapter" data-level="7.2" data-path="functional-programming.html"><a href="functional-programming.html#closures"><i class="fa fa-check"></i><b>7.2</b> Closures</a></li>
<li class="chapter" data-level="7.3" data-path="functional-programming.html"><a href="functional-programming.html#lists-of-functions"><i class="fa fa-check"></i><b>7.3</b> Lists of functions</a></li>
<li class="chapter" data-level="7.4" data-path="functional-programming.html"><a href="functional-programming.html#case-study-numerical-integration"><i class="fa fa-check"></i><b>7.4</b> Case study: numerical integration</a></li>
</ul></li>
<li class="chapter" data-level="8" data-path="functionals.html"><a href="functionals.html"><i class="fa fa-check"></i><b>8</b> Functionals</a><ul>
<li class="chapter" data-level="8.1" data-path="functionals.html"><a href="functionals.html#my-first-functional-lapply"><i class="fa fa-check"></i><b>8.1</b> My first functional: lapply()</a></li>
<li class="chapter" data-level="8.2" data-path="functionals.html"><a href="functionals.html#for-loops-functionals-friends-of-lapply"><i class="fa fa-check"></i><b>8.2</b> For loops functionals: friends of lapply():</a></li>
<li class="chapter" data-level="8.3" data-path="functionals.html"><a href="functionals.html#manipulating-matrices-and-data-frames"><i class="fa fa-check"></i><b>8.3</b> Manipulating matrices and data frames</a></li>
<li class="chapter" data-level="8.4" data-path="functionals.html"><a href="functionals.html#manipulating-lists"><i class="fa fa-check"></i><b>8.4</b> Manipulating lists</a></li>
<li class="chapter" data-level="8.5" data-path="functionals.html"><a href="functionals.html#mathematical-functionals"><i class="fa fa-check"></i><b>8.5</b> Mathematical functionals</a></li>
<li class="chapter" data-level="8.6" data-path="functionals.html"><a href="functionals.html#a-family-of-functions"><i class="fa fa-check"></i><b>8.6</b> A family of functions</a></li>
</ul></li>
<li class="chapter" data-level="9" data-path="function-operators.html"><a href="function-operators.html"><i class="fa fa-check"></i><b>9</b> Function operators</a><ul>
<li class="chapter" data-level="9.1" data-path="function-operators.html"><a href="function-operators.html#behavioural-fos"><i class="fa fa-check"></i><b>9.1</b> Behavioural FOs</a></li>
<li class="chapter" data-level="9.2" data-path="function-operators.html"><a href="function-operators.html#output-fos"><i class="fa fa-check"></i><b>9.2</b> Output FOs</a></li>
<li class="chapter" data-level="9.3" data-path="function-operators.html"><a href="function-operators.html#input-fos"><i class="fa fa-check"></i><b>9.3</b> Input FOs</a></li>
<li class="chapter" data-level="9.4" data-path="function-operators.html"><a href="function-operators.html#combining-fos"><i class="fa fa-check"></i><b>9.4</b> Combining FOs</a></li>
</ul></li>
<li class="chapter" data-level="10" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html"><i class="fa fa-check"></i><b>10</b> Non standard evaluation</a><ul>
<li class="chapter" data-level="10.1" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#capturing-expressions"><i class="fa fa-check"></i><b>10.1</b> Capturing expressions</a></li>
<li class="chapter" data-level="10.2" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#non-standard-evaluation-in-subset"><i class="fa fa-check"></i><b>10.2</b> Non standard evaluation in subset</a></li>
<li class="chapter" data-level="10.3" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#scoping-issues"><i class="fa fa-check"></i><b>10.3</b> Scoping issues</a></li>
<li class="chapter" data-level="10.4" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#calling-from-another-function"><i class="fa fa-check"></i><b>10.4</b> Calling from another function</a></li>
<li class="chapter" data-level="10.5" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#substitute"><i class="fa fa-check"></i><b>10.5</b> Substitute</a></li>
<li class="chapter" data-level="10.6" data-path="non-standard-evaluation.html"><a href="non-standard-evaluation.html#the-downsides-of-non-standard-evaluation"><i class="fa fa-check"></i><b>10.6</b> The downsides of non-standard evaluation</a></li>
</ul></li>
<li class="chapter" data-level="11" data-path="expressions.html"><a href="expressions.html"><i class="fa fa-check"></i><b>11</b> Expressions</a><ul>
<li class="chapter" data-level="11.1" data-path="expressions.html"><a href="expressions.html#structure-of-expressions"><i class="fa fa-check"></i><b>11.1</b> Structure of expressions</a></li>
<li class="chapter" data-level="11.2" data-path="expressions.html"><a href="expressions.html#names"><i class="fa fa-check"></i><b>11.2</b> Names</a></li>
<li class="chapter" data-level="11.3" data-path="expressions.html"><a href="expressions.html#calls"><i class="fa fa-check"></i><b>11.3</b> Calls</a></li>
<li class="chapter" data-level="11.4" data-path="expressions.html"><a href="expressions.html#capturing-the-current-call"><i class="fa fa-check"></i><b>11.4</b> Capturing the current call</a></li>
<li class="chapter" data-level="11.5" data-path="expressions.html"><a href="expressions.html#pairlists"><i class="fa fa-check"></i><b>11.5</b> Pairlists</a></li>
<li class="chapter" data-level="11.6" data-path="expressions.html"><a href="expressions.html#parsing-and-deparsing"><i class="fa fa-check"></i><b>11.6</b> Parsing and deparsing</a></li>
<li class="chapter" data-level="11.7" data-path="expressions.html"><a href="expressions.html#walking-the-ast-with-recursive-functions"><i class="fa fa-check"></i><b>11.7</b> Walking the AST with recursive functions</a></li>
</ul></li>
<li class="chapter" data-level="12" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html"><i class="fa fa-check"></i><b>12</b> Domain specific languages</a><ul>
<li class="chapter" data-level="12.1" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#html"><i class="fa fa-check"></i><b>12.1</b> HTML</a></li>
<li class="chapter" data-level="12.2" data-path="domain-specific-languages.html"><a href="domain-specific-languages.html#latex"><i class="fa fa-check"></i><b>12.2</b> LaTeX</a></li>
</ul></li>
<li class="chapter" data-level="13" data-path="performance.html"><a href="performance.html"><i class="fa fa-check"></i><b>13</b> Performance</a><ul>
<li class="chapter" data-level="13.1" data-path="performance.html"><a href="performance.html#microbenchmarking"><i class="fa fa-check"></i><b>13.1</b> Microbenchmarking</a></li>
<li class="chapter" data-level="13.2" data-path="performance.html"><a href="performance.html#language-performance"><i class="fa fa-check"></i><b>13.2</b> Language performance</a></li>
<li class="chapter" data-level="13.3" data-path="performance.html"><a href="performance.html#implementations-performance"><i class="fa fa-check"></i><b>13.3</b> Implementations performance</a></li>
</ul></li>
<li class="chapter" data-level="14" data-path="profiling.html"><a href="profiling.html"><i class="fa fa-check"></i><b>14</b> Profiling</a><ul>
<li class="chapter" data-level="14.1" data-path="profiling.html"><a href="profiling.html#has-somebody-already-solved-the-problem"><i class="fa fa-check"></i><b>14.1</b> Has somebody already solved the problem?</a></li>
<li class="chapter" data-level="14.2" data-path="profiling.html"><a href="profiling.html#do-as-little-as-possible"><i class="fa fa-check"></i><b>14.2</b> Do as little as possible</a></li>
<li class="chapter" data-level="14.3" data-path="profiling.html"><a href="profiling.html#vectorise"><i class="fa fa-check"></i><b>14.3</b> Vectorise</a></li>
</ul></li>
<li class="chapter" data-level="15" data-path="memory.html"><a href="memory.html"><i class="fa fa-check"></i><b>15</b> Memory</a><ul>
<li class="chapter" data-level="15.1" data-path="memory.html"><a href="memory.html#object-size"><i class="fa fa-check"></i><b>15.1</b> Object size</a></li>
<li class="chapter" data-level="15.2" data-path="memory.html"><a href="memory.html#memory-profiling-with-lineprof"><i class="fa fa-check"></i><b>15.2</b> Memory profiling with lineprof</a></li>
<li class="chapter" data-level="15.3" data-path="memory.html"><a href="memory.html#modification-in-place"><i class="fa fa-check"></i><b>15.3</b> Modification in place</a></li>
</ul></li>
<li class="chapter" data-level="16" data-path="rcpp.html"><a href="rcpp.html"><i class="fa fa-check"></i><b>16</b> Rcpp</a><ul>
<li class="chapter" data-level="16.1" data-path="rcpp.html"><a href="rcpp.html#getting-started-with-c"><i class="fa fa-check"></i><b>16.1</b> Getting started with C++</a></li>
<li class="chapter" data-level="16.2" data-path="rcpp.html"><a href="rcpp.html#missing-values"><i class="fa fa-check"></i><b>16.2</b> Missing values</a></li>
<li class="chapter" data-level="16.3" data-path="rcpp.html"><a href="rcpp.html#the-stl"><i class="fa fa-check"></i><b>16.3</b> The STL</a></li>
</ul></li>
<li class="chapter" data-level="17" data-path="testchapter.html"><a href="testchapter.html"><i class="fa fa-check"></i><b>17</b> Testchapter</a></li>
<li class="chapter" data-level="18" data-path="s3-1.html"><a href="s3-1.html"><i class="fa fa-check"></i><b>18</b> S3</a><ul>
<li class="chapter" data-level="18.1" data-path="s3-1.html"><a href="s3-1.html#basics"><i class="fa fa-check"></i><b>18.1</b> Basics</a></li>
<li class="chapter" data-level="18.2" data-path="s3-1.html"><a href="s3-1.html#classes"><i class="fa fa-check"></i><b>18.2</b> Classes</a></li>
<li class="chapter" data-level="18.3" data-path="s3-1.html"><a href="s3-1.html#generics-and-methods"><i class="fa fa-check"></i><b>18.3</b> Generics and methods</a></li>
<li class="chapter" data-level="18.4" data-path="s3-1.html"><a href="s3-1.html#method-dispatch"><i class="fa fa-check"></i><b>18.4</b> Method dispatch</a></li>
<li class="chapter" data-level="18.5" data-path="s3-1.html"><a href="s3-1.html#inheritance"><i class="fa fa-check"></i><b>18.5</b> Inheritance</a></li>
<li class="chapter" data-level="18.6" data-path="s3-1.html"><a href="s3-1.html#dispatch-details"><i class="fa fa-check"></i><b>18.6</b> Dispatch details</a></li>
</ul></li>
<li class="chapter" data-level="19" data-path="s4-1.html"><a href="s4-1.html"><i class="fa fa-check"></i><b>19</b> S4</a><ul>
<li class="chapter" data-level="19.1" data-path="s4-1.html"><a href="s4-1.html#classes-1"><i class="fa fa-check"></i><b>19.1</b> Classes</a></li>
<li class="chapter" data-level="19.2" data-path="s4-1.html"><a href="s4-1.html#generics-and-methods-1"><i class="fa fa-check"></i><b>19.2</b> Generics and methods</a></li>
<li class="chapter" data-level="19.3" data-path="s4-1.html"><a href="s4-1.html#method-dispatch-1"><i class="fa fa-check"></i><b>19.3</b> Method dispatch</a></li>
<li class="chapter" data-level="19.4" data-path="s4-1.html"><a href="s4-1.html#s4-and-existing-code"><i class="fa fa-check"></i><b>19.4</b> S4 and existing code</a><ul>
<li class="chapter" data-level="19.4.1" data-path="s4-1.html"><a href="s4-1.html#exercises"><i class="fa fa-check"></i><b>19.4.1</b> Exercises</a></li>
</ul></li>
</ul></li>
</ul>

      </nav>
    </div>

    <div class="book-body">
      <div class="body-inner">
        <div class="book-header" role="navigation">
          <h1>
            <i class="fa fa-circle-o-notch fa-spin"></i><a href="./">Advanced R Solutions</a>
          </h1>
        </div>

        <div class="page-wrapper" tabindex="-1" role="main">
          <div class="page-inner">

            <section class="normal" id="section-">
<div id="expressions" class="section level1">
<h1><span class="header-section-number">11</span> Expressions</h1>
<div id="structure-of-expressions" class="section level2">
<h2><span class="header-section-number">11.1</span> Structure of expressions</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: There’s no existing base function that checks if an element is a valid component of an expression (i.e., it’s a constant, name, call, or pairlist). Implement one by guessing the names of the “is” functions for calls, names, and pairlists.</p>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">is.valid &lt;-<span class="st"> </span><span class="cf">function</span>(x){
  out &lt;-<span class="st"> </span><span class="ot">FALSE</span>
  <span class="cf">if</span>(<span class="kw">is.atomic</span>(x) <span class="op">&amp;</span><span class="st"> </span><span class="kw">length</span>(x) <span class="op">==</span><span class="st"> </span><span class="dv">1</span>){out &lt;-<span class="st"> </span><span class="ot">TRUE</span>}
  <span class="co"># another possibility to check for constants would be</span>
  <span class="co"># identical(x, substitute(x))</span>
  <span class="cf">if</span>(<span class="kw">is.call</span>(x)){out &lt;-<span class="st"> </span><span class="ot">TRUE</span>}
  <span class="cf">if</span>(<span class="kw">is.name</span>(x)){out &lt;-<span class="st"> </span><span class="ot">TRUE</span>}
  <span class="cf">if</span>(<span class="kw">is.pairlist</span>(x)){out &lt;-<span class="st"> </span><span class="ot">TRUE</span>}
  out
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>pryr::ast()</code> uses non-standard evaluation. What’s its escape hatch to standard evaluation?</p>
<p><strong><span style="color:green">A</span></strong>: You can call <code>pryr::call_tree</code> directly.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: What does the call tree of an if statement with multiple else conditions look like?</p>
<p><strong><span style="color:green">A</span></strong>: It depends a little bit how it is written. Here the infix version:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr<span class="op">::</span><span class="kw">ast</span>(<span class="st">`</span><span class="dt">if</span><span class="st">`</span>(<span class="ot">FALSE</span>, <span class="st">&quot;first&quot;</span>,
               <span class="st">`</span><span class="dt">if</span><span class="st">`</span>(<span class="ot">TRUE</span>, <span class="st">&quot;second&quot;</span>,
                    <span class="st">`</span><span class="dt">if</span><span class="st">`</span>(<span class="ot">TRUE</span>, <span class="st">&quot;third&quot;</span>, <span class="st">&quot;fourth&quot;</span>))))
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \-  FALSE</span>
<span class="co">#&gt;   \-  &quot;first&quot;</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `if</span>
<span class="co">#&gt;     \-  TRUE</span>
<span class="co">#&gt;     \-  &quot;second&quot;</span>
<span class="co">#&gt;     \- ()</span>
<span class="co">#&gt;       \- `if</span>
<span class="co">#&gt;       \-  TRUE</span>
<span class="co">#&gt;       \-  &quot;third&quot;</span>
<span class="co">#&gt;       \-  &quot;fourth&quot;</span></code></pre></div>
<p>And here the “normal” version:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">if</span> (<span class="ot">FALSE</span>) {
  <span class="st">&quot;first&quot;</span>
  } <span class="cf">else</span> (
    <span class="cf">if</span> (<span class="ot">TRUE</span>) {
      <span class="st">&quot;second&quot;</span>
      } <span class="cf">else</span> (
        <span class="cf">if</span> (<span class="ot">TRUE</span>) {
          <span class="st">&quot;third&quot;</span>
          } <span class="cf">else</span> (
            <span class="st">&quot;fourth&quot;</span>
            )
        )
    ))
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \-  FALSE</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>
<span class="co">#&gt;     \-  &quot;first&quot;</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `(</span>
<span class="co">#&gt;     \- ()</span>
<span class="co">#&gt;       \- `if</span>
<span class="co">#&gt;       \-  TRUE</span>
<span class="co">#&gt;       \- ()</span>
<span class="co">#&gt;         \- `{</span>
<span class="co">#&gt;         \-  &quot;second&quot;</span>
<span class="co">#&gt;       \- ()</span>
<span class="co">#&gt;         \- `(</span>
<span class="co">#&gt;         \- ()</span>
<span class="co">#&gt;           \- `if</span>
<span class="co">#&gt;           \-  TRUE</span>
<span class="co">#&gt;           \- ()</span>
<span class="co">#&gt;             \- `{</span>
<span class="co">#&gt;             \-  &quot;third&quot;</span>
<span class="co">#&gt;           \- ()</span>
<span class="co">#&gt;             \- `(</span>
<span class="co">#&gt;             \-  &quot;fourth&quot;</span></code></pre></div>
<p>However, under the hood the language will call another base <code>if</code> statement. So <code>else if</code> seems to be for human readibility.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Compare <code>ast(x + y %+% z)</code> to <code>ast(x ^ y %+% z)</code>. What do they tell you about the precedence of custom infix functions?</p>
<p><strong><span style="color:green">A</span></strong>: Comparison of the syntax trees:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># for ast(x + y %+% z)</span>
<span class="co"># y %+% z will be calculated first and the result will be added to x</span>
pryr<span class="op">::</span><span class="kw">ast</span>(x <span class="op">+</span><span class="st"> </span>y <span class="op">%+%</span><span class="st"> </span>z)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `+</span>
<span class="co">#&gt;   \- `x</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `%+%</span>
<span class="co">#&gt;     \- `y</span>
<span class="co">#&gt;     \- `z</span>

<span class="co"># for ast(x ^ y %+% z)</span>
<span class="co"># x^y will be calculated first, and the result will be used as first argument of `%+%()`</span>
pryr<span class="op">::</span><span class="kw">ast</span>(x <span class="op">^</span><span class="st"> </span>y <span class="op">%+%</span><span class="st"> </span>z)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `%+%</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `^</span>
<span class="co">#&gt;     \- `x</span>
<span class="co">#&gt;     \- `y</span>
<span class="co">#&gt;   \- `z</span></code></pre></div>
<p>So we can conclude that custom infix functions must have a precedence between addition and exponentiation. The general precedence rules can be found for example <a href="https://cran.r-project.org/doc/manuals/r-release/R-lang.html">here</a></p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Why can’t an expression contain an atomic vector of length greater than one? Which one of the six types of atomic vector can’t appear in an expression? Why?</p>
<p><strong><span style="color:green">A</span></strong>: Because you can’t type an expression that evaluates to an atomic of greater length than one without using a function, which means that these expressions would be calls. Also raws can’t appear in expressions, because of a similar reason. We think they are impossible to construct without using <code>as.raw</code>, which would mean that we will also end up with a call.</p>
<p>Note also that imaginary parts of complex numbers work:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">pryr<span class="op">::</span><span class="kw">ast</span>(1i)
<span class="co">#&gt; \-  0+1i</span></code></pre></div></li>
</ol>
</div>
<div id="names" class="section level2">
<h2><span class="header-section-number">11.2</span> Names</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: You can use <code>formals()</code> to both get and set the arguments of a function. Use <code>formals()</code> to modify the following function so that the default value of <code>x</code> is missing and <code>y</code> is 10.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">g &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="dv">20</span>, y) {
  x <span class="op">+</span><span class="st"> </span>y
}</code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">formals</span>(g) &lt;-<span class="st"> </span><span class="kw">alist</span>(<span class="dt">x =</span> , <span class="dt">y =</span> <span class="dv">10</span>)</code></pre></div>
<p>Similarly one can change the body of the function through <code>body&lt;-()</code> and also the environment via <code>environment&lt;-()</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write an equivalent to <code>get()</code> using <code>as.name()</code> and <code>eval()</code>. Write an equivalent to <code>assign()</code> using <code>as.name()</code>, <code>substitute()</code>, and <code>eval()</code>. (Don’t worry about the multiple ways of choosing an environment; assume that the user supplies it explicitly.)</p>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">get3 &lt;-<span class="st"> </span><span class="cf">function</span>(x, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="kw">eval</span>(<span class="kw">as.name</span>(x), env)
}

assign3 &lt;-<span class="st"> </span><span class="cf">function</span>(x, value, env) {
  <span class="kw">eval</span>(<span class="kw">substitute</span>(x &lt;-<span class="st"> </span>value,<span class="kw">list</span>(<span class="dt">x =</span> <span class="kw">as.name</span>(x), <span class="dt">value =</span> value)), env)
  <span class="cf">if</span> (<span class="kw">length</span>(x) <span class="op">&gt;</span><span class="st"> </span><span class="dv">1</span>)
    <span class="kw">warning</span>(<span class="st">&#39;only the first element is used as variable name&#39;</span>)
}</code></pre></div></li>
</ol>
</div>
<div id="calls" class="section level2">
<h2><span class="header-section-number">11.3</span> Calls</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: The following two calls look the same, but are actually different:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">(a &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>))
<span class="co">#&gt; mean(1:10)</span>
(b &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="kw">quote</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
<span class="co">#&gt; mean(1:10)</span>
<span class="kw">identical</span>(a, b)
<span class="co">#&gt; [1] FALSE</span></code></pre></div>
<p>What’s the difference? Which one should you prefer?</p>
<p><strong><span style="color:orange">A</span></strong>: <code>call</code> evalulates its <code>...</code> arguments. So in the first call <code>1:10</code> will be evaluated to an integer (1, 2, 3, …, 10) and in the second call <code>quote()</code> compensates the effect of the evaluation, so that <code>b</code>’s second element will be the expression <code>1:10</code> (which is again a call):</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">as.list</span>(a)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; mean</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt;  [1]  1  2  3  4  5  6  7  8  9 10</span>
<span class="kw">as.list</span>(b)
<span class="co">#&gt; [[1]]</span>
<span class="co">#&gt; mean</span>
<span class="co">#&gt; </span>
<span class="co">#&gt; [[2]]</span>
<span class="co">#&gt; 1:10</span></code></pre></div>
<p>We can create an example, where we can see the consequences directly:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># h &lt;- call(&quot;mean&quot;, z)</span>
##&gt; Error: object &#39;z&#39; not found

h &lt;-<span class="st"> </span><span class="kw">call</span>(<span class="st">&quot;mean&quot;</span>, <span class="kw">quote</span>(z))
<span class="co"># eval(h)</span>
##&gt; Error in mean(z) : object &#39;z&#39; not found
z &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="dv">10</span>
<span class="kw">eval</span>(h)
<span class="co">#&gt; [1] 5.5</span></code></pre></div>
<p>From my intuition I would prefer the second version, since it behaves more like lazy evaluation, but I am not sure if this is the correct answer as indended by the exercise.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Implement a pure R version of <code>do.call()</code>.</p>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">do.call2 &lt;-<span class="st"> </span><span class="cf">function</span>(what, args, <span class="dt">quote =</span> <span class="ot">FALSE</span>, <span class="dt">env =</span> <span class="kw">parent.frame</span>()){
  <span class="cf">if</span>(<span class="op">!</span><span class="kw">is.list</span>(args))
    <span class="kw">stop</span>(<span class="st">&quot;second argument must be a list&quot;</span>)
  <span class="cf">if</span> (quote) 
    args &lt;-<span class="st"> </span><span class="kw">lapply</span>(args, enquote)
  <span class="kw">eval</span>(<span class="kw">as.call</span>(<span class="kw">c</span>(what, args)), env)
}</code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Concatenating a call and an expression with <code>c()</code> creates a list. Implement <code>concat()</code> so that the following code works to combine a call and an additional argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">concat</span>(<span class="kw">quote</span>(f), <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="kw">quote</span>(<span class="kw">mean</span>(a)))
<span class="co">#&gt; f(a = 1, b = mean(a))</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">concat &lt;-<span class="st"> </span><span class="cf">function</span>(f, ...){
  <span class="kw">as.call</span>(<span class="kw">c</span>(f, <span class="kw">list</span>(...)))
}
<span class="kw">concat</span>(<span class="kw">quote</span>(f), <span class="dt">a =</span> <span class="dv">1</span>, <span class="dt">b =</span> <span class="kw">quote</span>(<span class="kw">mean</span>(a)))
<span class="co">#&gt; f(a = 1, b = mean(a))</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Since <code>list()</code>s don’t belong in expressions, we could create a more convenient call constructor that automatically combines lists into the arguments. Implement <code>make_call()</code> so that the following code works.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">list</span>(<span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; mean(x, na.rm = TRUE)</span>
<span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; mean(x, na.rm = TRUE)</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">make_call &lt;-<span class="st"> </span><span class="cf">function</span>(x, ...){
  <span class="kw">as.call</span>(<span class="kw">c</span>(x, ...))
}

<span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">list</span>(<span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>))
<span class="co">#&gt; mean(x, na.rm = TRUE)</span>
<span class="kw">make_call</span>(<span class="kw">quote</span>(mean), <span class="kw">quote</span>(x), <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)
<span class="co">#&gt; mean(x, na.rm = TRUE)</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: How does <code>mode&lt;-</code> work? How does it use <code>call()</code>?</p>
<p><strong><span style="color:green">A</span></strong>: We can explain it best, when we comment the source code:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> (x) 
  {
  <span class="co"># when x is an expression, mode will(x) return &quot;expression&quot;</span>
  <span class="cf">if</span> (<span class="kw">is.expression</span>(x)) 
    <span class="kw">return</span>(<span class="st">&quot;expression&quot;</span>)
  <span class="co"># when x is a call (or language, which is exactly the same), the first element </span>
  <span class="co"># of the call will be coerced to character. </span>
  <span class="co"># If the call is an autoprinting (like in quote((1))), mode will return &quot;(&quot;.</span>
  <span class="co"># For any other call, mode will return &quot;call&quot; </span>
  <span class="cf">if</span> (<span class="kw">is.call</span>(x)) 
    <span class="kw">return</span>(<span class="cf">switch</span>(<span class="kw">deparse</span>(x[[1L]])[1L], <span class="st">`</span><span class="dt">(</span><span class="st">`</span> =<span class="st"> &quot;(&quot;</span>, <span class="st">&quot;call&quot;</span>))
  <span class="co"># if x is a name (or a symbol, which is exactly the same), then mode will return &quot;name&quot;</span>
  <span class="cf">if</span> (<span class="kw">is.name</span>(x)) 
    <span class="st">&quot;name&quot;</span>
  <span class="co"># otherwise, mode will return dependent on typeof(x). If typeof(x) is double or integer, </span>
  <span class="co"># mode will return &quot;numeric&quot;. If typeof(x) is closure, builtin or special, mode(x) will</span>
  <span class="co"># return &quot;function&quot;. And in all other cases, mode will just return typeof(x)</span>
  <span class="cf">else</span> <span class="cf">switch</span>(tx &lt;-<span class="st"> </span><span class="kw">typeof</span>(x), <span class="dt">double =</span> , <span class="dt">integer =</span> <span class="st">&quot;numeric&quot;</span>, 
              <span class="dt">closure =</span> , <span class="dt">builtin =</span> , <span class="dt">special =</span> <span class="st">&quot;function&quot;</span>, tx)
  }
<span class="op">&lt;</span>bytecode<span class="op">:</span><span class="st"> </span><span class="dv">0x000000000c4e66e0</span><span class="op">&gt;</span>
<span class="st">  </span><span class="er">&lt;</span>environment<span class="op">:</span><span class="st"> </span>namespace<span class="op">:</span>base<span class="op">&gt;</span></code></pre></div>
<p>As commented above, <code>mode()</code> uses <code>is.call()</code> to distinguish autoprint- and “normal” calls with the help of a separate <code>switch()</code>.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Read the source for <code>pryr::standardise_call()</code>. How does it work? Why is <code>is.primitive()</code> needed?</p>
<p><strong><span style="color:green">A</span></strong>: It evaluates the first element of the call, which is usually the name of a function, but can also be another call. Then is uses <code>match.call()</code> to get the standard names for all the arguments.</p>
<p><code>is.primitive()</code> is used as an escape to just return the call instead of using <code>match.call()</code> if the function passed is a primitive. This is done because <code>match.call()</code> does not work for primitives.</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>standardise_call()</code> doesn’t work so well for the following calls. Why?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(pryr)
<span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, <span class="dt">na.rm =</span> <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, na.rm = TRUE)</span>
<span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">n =</span> T, <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>)))
<span class="co">#&gt; mean(x = 1:10, n = T)</span>
<span class="kw">standardise_call</span>(<span class="kw">quote</span>(<span class="kw">mean</span>(<span class="dt">x =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">10</span>, , <span class="ot">TRUE</span>)))
<span class="co">#&gt; mean(x = 1:10, , TRUE)</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Read the documentation for <code>pryr::modify_call()</code>. How do you think it works? Read the source code.</p>
<p><strong><span style="color:green">A</span></strong>: Again, we explain by commenting the source</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="cf">function</span> (call, new_args) {
  <span class="co"># check if call is a call and new_args is a list</span>
  <span class="kw">stopifnot</span>(<span class="kw">is.call</span>(call), <span class="kw">is.list</span>(new_args))
  <span class="co"># standardise the call</span>
  call &lt;-<span class="st"> </span><span class="kw">standardise_call</span>(call)
  <span class="co"># check if the supplied new_args list has any unnamed elements.</span>
  <span class="co"># if so, an error occurs.</span>
  nms &lt;-<span class="st"> </span><span class="kw">names</span>(new_args) <span class="op">%||%</span><span class="st"> </span><span class="kw">rep</span>(<span class="st">&quot;&quot;</span>, <span class="kw">length</span>(new_args))
  <span class="cf">if</span> (<span class="kw">any</span>(nms <span class="op">==</span><span class="st"> &quot;&quot;</span>)) {
    <span class="kw">stop</span>(<span class="st">&quot;All new arguments must be named&quot;</span>, <span class="dt">call. =</span> <span class="ot">FALSE</span>)
    }
  <span class="co"># every name element of the call, for which a new argument was supplied by the user,</span>
  <span class="co"># becomes overwritten</span>
  <span class="cf">for</span> (nm <span class="cf">in</span> nms) {
    call[[nm]] &lt;-<span class="st"> </span>new_args[[nm]]
    }
  <span class="co"># finally the modified call is returned</span>
  call
}
<span class="op">&lt;</span>environment<span class="op">:</span><span class="st"> </span>namespace<span class="op">:</span>pryr<span class="op">&gt;</span></code></pre></div></li>
<li><p><strong><span style="color:red">Q</span></strong>: Use <code>ast()</code> and experimentation to figure out the three arguments in an <code>if()</code> call. Which components are required? What are the arguments to the <code>for()</code> and <code>while()</code> calls?</p>
<p><strong><span style="color:green">A</span></strong>:</p>
<p><strong>if:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## All these return an error
<span class="co"># pryr::ast(if)</span>
<span class="co"># pryr::ast(if())</span>
<span class="co"># pryr::ast(if{})</span>
<span class="co"># pryr::ast(if(){})</span>
<span class="co"># pryr::ast(if(TRUE))</span>

## This is the minimum required
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">if</span>(<span class="ot">TRUE</span>){<span class="dv">1</span>})
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \-  TRUE</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>
<span class="co">#&gt;     \-  1</span>

## One can also supply an alternative expression
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">if</span>(<span class="ot">TRUE</span>){}
          <span class="cf">else</span> {<span class="dv">3</span>})
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \-  TRUE</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>
<span class="co">#&gt;     \-  3</span>

## However, one has to supply the compound expression (the first one),
## otherwise we get an error
<span class="co"># pryr::ast(if(TRUE)</span>
<span class="co">#           else {3})</span>

<span class="co"># So this is how if basically works</span>
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">if</span>(cond)expr)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `if</span>
<span class="co">#&gt;   \- `cond</span>
<span class="co">#&gt;   \- `expr</span>

<span class="co"># and here within a call</span>
<span class="kw">eval</span>(<span class="kw">call</span>(<span class="st">&quot;if&quot;</span>, <span class="ot">TRUE</span>, <span class="dv">1</span>))
<span class="co">#&gt; [1] 1</span>
<span class="kw">eval</span>(<span class="kw">call</span>(<span class="st">&quot;if&quot;</span>, <span class="ot">TRUE</span>, <span class="dv">1</span>, <span class="dv">2</span>))
<span class="co">#&gt; [1] 1</span>
<span class="kw">eval</span>(<span class="kw">call</span>(<span class="st">&quot;if&quot;</span>, <span class="ot">FALSE</span>, <span class="dv">1</span>, <span class="dv">2</span>))
<span class="co">#&gt; [1] 2</span></code></pre></div>
<p><strong>for:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## All these return an error
<span class="co"># pryr::ast(for)</span>
<span class="co"># pryr::ast(for{})</span>
<span class="co"># pryr::ast(for())</span>
<span class="co"># pryr::ast(for(){})</span>
<span class="co"># pryr::ast(for(in){})</span>
<span class="co"># pryr::ast(for(var in){})</span>
<span class="co"># pryr::ast(for(var in 10))</span>
<span class="co"># pryr::ast(for(in 10){})</span>

## This is the minimum required
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">for</span>(var <span class="cf">in</span> <span class="dv">10</span>){})
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `for</span>
<span class="co">#&gt;   \- `var</span>
<span class="co">#&gt;   \-  10</span>
<span class="co">#&gt;   \- ()</span>
<span class="co">#&gt;     \- `{</span>

## So this is how for basically works
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">for</span>(var <span class="cf">in</span> seq)expr)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `for</span>
<span class="co">#&gt;   \- `var</span>
<span class="co">#&gt;   \- `seq</span>
<span class="co">#&gt;   \- `expr</span>

## And here within a call (note that we need quote, since var has to be a nanme
## and expr has to be an expression)
<span class="kw">eval</span>(<span class="kw">call</span>(<span class="st">&quot;for&quot;</span>, <span class="dt">var =</span> <span class="kw">quote</span>(i), <span class="dt">seq =</span> <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="dt">expr =</span> <span class="kw">quote</span>(<span class="kw">print</span>(i))))
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; [1] 3</span>

## as infix function it looks a little bit easier
<span class="st">`</span><span class="dt">for</span><span class="st">`</span>(i, <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>, <span class="kw">print</span>(i))
<span class="co">#&gt; [1] 1</span>
<span class="co">#&gt; [1] 2</span>
<span class="co">#&gt; [1] 3</span></code></pre></div>
<p><strong>while:</strong></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">## All these return an error
<span class="co"># pryr::ast(while)</span>
<span class="co"># pryr::ast(while())</span>
<span class="co"># pryr::ast(while(TRUE))</span>
<span class="co"># pryr::ast(while(){})</span>
<span class="co"># pryr::ast(while()1)</span>
<span class="co"># pryr::ast(while(TRUE){})</span>

## This is the minimum required
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">while</span>(<span class="ot">TRUE</span>)<span class="dv">1</span>)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `while</span>
<span class="co">#&gt;   \-  TRUE</span>
<span class="co">#&gt;   \-  1</span>

## So this is how while basically works
pryr<span class="op">::</span><span class="kw">ast</span>(<span class="cf">while</span>(cond)expr)
<span class="co">#&gt; \- ()</span>
<span class="co">#&gt;   \- `while</span>
<span class="co">#&gt;   \- `cond</span>
<span class="co">#&gt;   \- `expr</span>

## And here within a call (infinite loop in this case)
<span class="co"># eval(call(&quot;while&quot;, TRUE , 1))</span></code></pre></div></li>
</ol>
</div>
<div id="capturing-the-current-call" class="section level2">
<h2><span class="header-section-number">11.4</span> Capturing the current call</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: Compare and contrast <code>update_model()</code> with <code>update.default()</code>.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Why doesn’t <code>write.csv(mtcars, &quot;mtcars.csv&quot;, row = FALSE)</code> work? What property of argument matching has the original author forgotten?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Rewrite <code>update.formula()</code> to use R code instead of C code.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Sometimes it’s necessary to uncover the function that called the function that called the current function (i.e., the grandparent, not the parent). How can you use <code>sys.call()</code> or <code>match.call()</code> to find this function?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
</ol>
</div>
<div id="pairlists" class="section level2">
<h2><span class="header-section-number">11.5</span> Pairlists</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: How are <code>alist(a)</code> and <code>alist(a = )</code> different? Think about both the input and the output.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Read the documentation and source code for <code>pryr::partial()</code>. What does it do? How does it work? Read the documentation and source code for <code>pryr::unenclose()</code>. What does it do and how does it work?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: The actual implementation of <code>curve()</code> looks more like</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">curve3 &lt;-<span class="st"> </span><span class="cf">function</span>(expr, <span class="dt">xlim =</span> <span class="kw">c</span>(<span class="dv">0</span>, <span class="dv">1</span>), <span class="dt">n =</span> <span class="dv">100</span>,
                   <span class="dt">env =</span> <span class="kw">parent.frame</span>()) {
  env2 &lt;-<span class="st"> </span><span class="kw">new.env</span>(<span class="dt">parent =</span> env)
  env2<span class="op">$</span>x &lt;-<span class="st"> </span><span class="kw">seq</span>(xlim[<span class="dv">1</span>], xlim[<span class="dv">2</span>], <span class="dt">length =</span> n)

  y &lt;-<span class="st"> </span><span class="kw">eval</span>(<span class="kw">substitute</span>(expr), env2)
  <span class="kw">plot</span>(env2<span class="op">$</span>x, y, <span class="dt">type =</span> <span class="st">&quot;l&quot;</span>, 
    <span class="dt">ylab =</span> <span class="kw">deparse</span>(<span class="kw">substitute</span>(expr)))
}</code></pre></div>
<p>How does this approach differ from <code>curve2()</code> defined above?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
</ol>
</div>
<div id="parsing-and-deparsing" class="section level2">
<h2><span class="header-section-number">11.6</span> Parsing and deparsing</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: What are the differences between <code>quote()</code> and <code>expression()</code>?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Read the help for <code>deparse()</code> and construct a call that <code>deparse()</code> and <code>parse()</code> do not operate symmetrically on.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Compare and contrast <code>source()</code> and <code>sys.source()</code>.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Modify <code>simple_source()</code> so it returns the result of <em>every</em> expression, not just the last one.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: The code generated by <code>simple_source()</code> lacks source references. Read the source code for <code>sys.source()</code> and the help for <code>srcfilecopy()</code>, then modify <code>simple_source()</code> to preserve source references. You can test your code by sourcing a function that contains a comment. If successful, when you look at the function, you’ll see the comment and not just the source code.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
</ol>
</div>
<div id="walking-the-ast-with-recursive-functions" class="section level2">
<h2><span class="header-section-number">11.7</span> Walking the AST with recursive functions</h2>
<ol style="list-style-type: decimal">
<li><p><strong><span style="color:red">Q</span></strong>: Why does <code>logical_abbr()</code> use a for loop instead of a functional like <code>lapply()</code>?</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: <code>logical_abbr()</code> works when given quoted objects, but doesn’t work when given an existing function, as in the example below. Why not? How could you modify <code>logical_abbr()</code> to work with functions? Think about what components make up a function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">f &lt;-<span class="st"> </span><span class="cf">function</span>(<span class="dt">x =</span> <span class="ot">TRUE</span>) {
  <span class="kw">g</span>(x <span class="op">+</span><span class="st"> </span>T)
}
<span class="kw">logical_abbr</span>(f)</code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write a function called <code>ast_type()</code> that returns either “constant”, “name”, “call”, or “pairlist”. Rewrite <code>logical_abbr()</code>, <code>find_assign()</code>, and <code>bquote2()</code> to use this function with <code>switch()</code> instead of nested if statements.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write a function that extracts all calls to a function. Compare your function to <code>pryr::fun_calls()</code>.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Write a wrapper around <code>bquote2()</code> that does non-standard evaluation so that you don’t need to explicitly <code>quote()</code> the input.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Compare <code>bquote2()</code> to <code>bquote()</code>. There is a subtle bug in <code>bquote()</code>: it won’t replace calls to functions with no arguments. Why?</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">bquote</span>(.(x)(), <span class="kw">list</span>(<span class="dt">x =</span> <span class="kw">quote</span>(f)))
<span class="co">#&gt; .(x)()</span>
<span class="kw">bquote</span>(.(x)(<span class="dv">1</span>), <span class="kw">list</span>(<span class="dt">x =</span> <span class="kw">quote</span>(f)))
<span class="co">#&gt; f(1)</span></code></pre></div>
<p><strong><span style="color:green">A</span></strong>:</p></li>
<li><p><strong><span style="color:red">Q</span></strong>: Improve the base <code>recurse_call()</code> template to also work with lists of functions and expressions (e.g., as from <code>parse(path_to_file))</code>.</p>
<p><strong><span style="color:green">A</span></strong>:</p></li>
</ol>

</div>
</div>
            </section>

          </div>
        </div>
      </div>
<a href="non-standard-evaluation.html" class="navigation navigation-prev " aria-label="Previous page"><i class="fa fa-angle-left"></i></a>
<a href="domain-specific-languages.html" class="navigation navigation-next " aria-label="Next page"><i class="fa fa-angle-right"></i></a>
    </div>
  </div>
<script src="libs/gitbook-2.6.7/js/app.min.js"></script>
<script src="libs/gitbook-2.6.7/js/lunr.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-search.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-sharing.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-fontsettings.js"></script>
<script src="libs/gitbook-2.6.7/js/plugin-bookdown.js"></script>
<script src="libs/gitbook-2.6.7/js/jquery.highlight.js"></script>
<script>
require(["gitbook"], function(gitbook) {
gitbook.start({
"sharing": {
"github": false,
"facebook": true,
"twitter": true,
"google": false,
"weibo": false,
"instapper": false,
"vk": false,
"all": ["facebook", "google", "twitter", "weibo", "instapaper"]
},
"fontsettings": {
"theme": "white",
"family": "sans",
"size": 2
},
"edit": {
"link": "https://github.com/Tazinho/Advanced-R-Solutions/edit/master/11-Expressions.Rmd",
"text": "Edit"
},
"download": null,
"toc": {
"collapse": "section",
"scroll_highlight": true
}
});
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://cdn.bootcss.com/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML";
    if (location.protocol !== "file:" && /^https?:/.test(script.src))
      script.src  = script.src.replace(/^https?:/, '');
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>
</body>

</html>
